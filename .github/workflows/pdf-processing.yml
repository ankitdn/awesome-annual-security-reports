name: PDF Processing Workflow

on:
  push:
    branches:
      - main
      - development
    paths:
      - 'Annual Security Reports/**/*.pdf'
  pull_request:
    branches:
      - main
      - development
    paths:
      - 'Annual Security Reports/**/*.pdf'

# Prevent workflow from running on legacy branch
if: ${{ github.ref != 'refs/heads/legacy' }}

jobs:
  pdf_detection:
    name: Detect New PDF Files
    runs-on: ubuntu-latest
    outputs:
      pdf_files: ${{ steps.detect-pdf.outputs.pdf_files }}
      is_owner: ${{ steps.check-contributor.outputs.is_owner }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need history to identify changes

      - name: Detect newly added PDF files
        id: detect-pdf
        run: |
          # Get list of all changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, get changed files in the PR
            CHANGED_FILES=$(git diff --name-status ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep "^A" | awk '{print $2}')
          else
            # For pushes, compare with previous commit
            CHANGED_FILES=$(git diff --name-status HEAD~1 HEAD | grep "^A" | awk '{print $2}')
          fi
          
          # Filter for only new PDF files in Annual Security Reports directory
          NEW_PDF_FILES=$(echo "$CHANGED_FILES" | grep -i "^Annual Security Reports/.*.pdf$" || echo "")
          
          if [[ -z "$NEW_PDF_FILES" ]]; then
            echo "No new PDF files detected in Annual Security Reports directory"
            echo "pdf_files=[]" >> $GITHUB_OUTPUT
          else
            # Format as JSON array for output
            JSON_ARRAY=$(echo "$NEW_PDF_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "New PDF files detected: $JSON_ARRAY"
            echo "pdf_files=$JSON_ARRAY" >> $GITHUB_OUTPUT
          fi

      - name: Check if contributor is repository owner
        id: check-contributor
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          EVENT_ACTOR="${{ github.actor }}"
          
          if [[ "$REPO_OWNER" == "$EVENT_ACTOR" ]]; then
            echo "Commit made by repository owner"
            echo "is_owner=true" >> $GITHUB_OUTPUT
          else
            echo "Commit made by external contributor"
            echo "is_owner=false" >> $GITHUB_OUTPUT
          fi

  falcon_scan:
    name: Falcon Hybrid-Analysis Scan
    needs: pdf_detection
    runs-on: ubuntu-latest
    if: ${{ needs.pdf_detection.outputs.pdf_files != '[]' }}
    outputs:
      scan_results: ${{ steps.scan-results.outputs.scan_results }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Scan files with Falcon Hybrid-Analysis
        id: scan-results
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
        run: |
          PDF_FILES='${{ needs.pdf_detection.outputs.pdf_files }}'
          SCAN_RESULTS='{}'
          HYBRID_ANALYSIS_API_URL="https://hybrid-analysis.com/api/v2"
          
          # Check API quota before proceeding
          QUOTA_INFO=$(curl -s -X GET "$HYBRID_ANALYSIS_API_URL/key/submission-quota" \
            -H "accept: application/json" \
            -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
            -H "User-Agent: GitHub-PDF-Workflow")
          
          echo "API Quota information: $(echo $QUOTA_INFO | jq 'del(.api_key)')"
          QUOTA_LEFT=$(echo $QUOTA_INFO | jq -r '.submission_quota_left')
          
          if [ $QUOTA_LEFT -le 0 ]; then
            echo "::error::No Falcon Hybrid-Analysis API quota remaining"
            exit 1
          fi
          
          # Process each PDF file in the list
          for PDF_FILE in $(echo $PDF_FILES | jq -r '.[]'); do
            echo "Scanning $PDF_FILE"
            
            # Submit the file for scanning
            SCAN_SUBMISSION=$(curl -s -X POST "$HYBRID_ANALYSIS_API_URL/quick-scan/submit" \
              -H "accept: application/json" \
              -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
              -H "User-Agent: GitHub-PDF-Workflow" \
              -F "file=@$PDF_FILE" \
              -F "environment_id=300" \
              -F "comment=GitHub Automatic Scan" \
              -F "default_sharing=true")
            
            # Check for submission errors
            if [ "$(echo $SCAN_SUBMISSION | jq -r '.has_errors')" == "true" ]; then
              ERROR_MSG=$(echo $SCAN_SUBMISSION | jq -r '.validation_errors // .error_message // "Unknown error"')
              echo "::error::Failed to submit $PDF_FILE for scanning: $ERROR_MSG"
              
              # Record the error in scan results
              FILE_BASENAME=$(basename "$PDF_FILE")
              SCAN_RESULTS=$(echo $SCAN_RESULTS | jq --arg file "$FILE_BASENAME" \
                                              --arg error "$ERROR_MSG" \
                                              --arg path "$PDF_FILE" \
                                              '. + {($file): {"status": "error", "error_message": $error, "path": $path, "is_clean": false}}')
              continue
            fi
            
            # Get the job ID for the scan
            JOB_ID=$(echo $SCAN_SUBMISSION | jq -r '.job_id')
            echo "Scan job submitted with ID: $JOB_ID"
            
            # Poll for the scan results (with timeout)
            MAX_ATTEMPTS=10
            ATTEMPTS=0
            STATUS_RAW=""
            
            while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              ATTEMPTS=$((ATTEMPTS+1))
              echo "Polling for scan results (attempt $ATTEMPTS/$MAX_ATTEMPTS)..."
              
              SCAN_RESULT=$(curl -s -X GET "$HYBRID_ANALYSIS_API_URL/quick-scan/$JOB_ID" \
                -H "accept: application/json" \
                -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
                -H "User-Agent: GitHub-PDF-Workflow")
              
              STATUS_RAW=$(echo $SCAN_RESULT | jq -r '.status_raw // ""')
              
              if [ "$STATUS_RAW" == "finished" ]; then
                echo "Scan completed successfully"
                break
              elif [ "$STATUS_RAW" == "error" ]; then
                echo "::warning::Scan encountered an error"
                break
              fi
              
              echo "Scan status: $STATUS_RAW"
              sleep 10
            done
            
            # Process the scan results
            FILE_BASENAME=$(basename "$PDF_FILE")
            
            if [ "$STATUS_RAW" != "finished" ]; then
              echo "::warning::Scan did not complete successfully for $FILE_BASENAME"
              ERROR_MSG=$(echo $SCAN_RESULT | jq -r '.error_message // "Scan did not complete"')
              
              SCAN_RESULTS=$(echo $SCAN_RESULTS | jq --arg file "$FILE_BASENAME" \
                                              --arg status "$STATUS_RAW" \
                                              --arg error "$ERROR_MSG" \
                                              --arg path "$PDF_FILE" \
                                              --arg job_id "$JOB_ID" \
                                              '. + {($file): {"status": $status, "error_message": $error, "job_id": $job_id, "path": $path, "is_clean": false}}')
              continue
            fi
            
            # Check scanner results
            SCANNER_RESULTS=$(echo $SCAN_RESULT | jq '.scanners_v2 // {}')
            
            # Look for any positive threat detections
            DETECTED_THREAT=$(echo $SCANNER_RESULTS | jq 'any((.ScanCrowdStrikeMl, .ScanCriminalIp, .ScanVt, .ScanMetaDefender) | select(. != null) | .detected == true)')
            SCAN_SCORE=$(echo $SCAN_RESULT | jq -r '.scan_result_score // 0')
            
            if [ "$DETECTED_THREAT" == "true" ] || [ $SCAN_SCORE -gt 50 ]; then
              echo "::warning::Threats detected in $FILE_BASENAME"
              THREAT_INFO=$(echo $SCANNER_RESULTS | jq -c '.')
              
              SCAN_RESULTS=$(echo $SCAN_RESULTS | jq --arg file "$FILE_BASENAME" \
                                              --arg job_id "$JOB_ID" \
                                              --arg score "$SCAN_SCORE" \
                                              --arg path "$PDF_FILE" \
                                              --argjson threats "$THREAT_INFO" \
                                              '. + {($file): {"status": "threat_detected", "job_id": $job_id, "scan_score": $score, "threats": $threats, "path": $path, "is_clean": false}}')
            else
              echo "No threats detected in $FILE_BASENAME"
              
              SCAN_RESULTS=$(echo $SCAN_RESULTS | jq --arg file "$FILE_BASENAME" \
                                              --arg job_id "$JOB_ID" \
                                              --arg score "$SCAN_SCORE" \
                                              --arg path "$PDF_FILE" \
                                              '. + {($file): {"status": "clean", "job_id": $job_id, "scan_score": $score, "path": $path, "is_clean": true}}')
            fi
          done
          
          # Output scan results
          echo "scan_results=$(echo $SCAN_RESULTS | jq -c .)" >> $GITHUB_OUTPUT
          echo "Scan results: $(echo $SCAN_RESULTS | jq .)"
          
          # Create issues for threat detections
          for FILE in $(echo $SCAN_RESULTS | jq -r 'keys[]'); do
            FILE_STATUS=$(echo $SCAN_RESULTS | jq -r --arg file "$FILE" '.[$file].status')
            
            if [ "$FILE_STATUS" != "clean" ]; then
              FILE_PATH=$(echo $SCAN_RESULTS | jq -r --arg file "$FILE" '.[$file].path')
              JOB_ID=$(echo $SCAN_RESULTS | jq -r --arg file "$FILE" '.[$file].job_id // "N/A"')
              ERROR_MSG=$(echo $SCAN_RESULTS | jq -r --arg file "$FILE" '.[$file].error_message // "N/A"')
              THREATS=$(echo $SCAN_RESULTS | jq -r --arg file "$FILE" '.[$file].threats // "N/A"')
              
              if [ -n "${{ secrets.REPO_ACCESS_TOKEN }}" ]; then
                ISSUE_TITLE="Security Scan Alert: $FILE"
                ISSUE_BODY="## Security Scan Alert\n\n**File:** $FILE_PATH\n\n**Status:** $FILE_STATUS\n\n**Job ID:** $JOB_ID\n\n"
                
                if [ "$ERROR_MSG" != "N/A" ]; then
                  ISSUE_BODY="$ISSUE_BODY**Error Message:** $ERROR_MSG\n\n"
                fi
                
                if [ "$THREATS" != "N/A" ]; then
                  ISSUE_BODY="$ISSUE_BODY**Threat Details:**\n\`\`\`json\n$THREATS\n\`\`\`\n\n"
                fi
                
                ISSUE_BODY="$ISSUE_BODY**Action Required:** Please review this PDF file as it may contain security threats or could not be properly scanned."
                
                curl -s -X POST "https://api.github.com/repos/${{ github.repository }}/issues" \
                  -H "Authorization: token ${{ secrets.REPO_ACCESS_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -d "{\"title\":\"$ISSUE_TITLE\",\"body\":\"$ISSUE_BODY\",\"labels\":[\"security\"]}"
                
                echo "Created issue for $FILE"
              else
                echo "::warning::No REPO_ACCESS_TOKEN provided, skipping issue creation for $FILE"
              fi
            fi
          done

      - name: Save scan results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: falcon-scan-results
          path: ./falcon-scan-results.json
          if-no-files-found: ignore
          retention-days: 7

  gemini_conversion:
    name: Gemini AI Markdown Conversion
    needs: [pdf_detection, falcon_scan]
    runs-on: ubuntu-latest
    if: ${{ needs.pdf_detection.outputs.pdf_files != '[]' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-generativeai PyPDF2 requests

      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          # Get the commit message for the AI prompt file
          PROMPT_COMMIT=$(git log -1 --format=%B -- AI_PROMPT_MARKDOWN_CONVERT.md)
          PROMPT_VERSION=$(echo "$PROMPT_COMMIT" | grep -o "V[0-9]\+\.[0-9]\+" || echo "V1.0")
          echo "Detected AI prompt version: $PROMPT_VERSION"
          echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT

      - name: Process clean PDF files
        id: process-pdfs
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          SCAN_RESULTS: ${{ needs.falcon_scan.outputs.scan_results }}
        run: |
          import os
          import json
          import sys
          import time
          import google.generativeai as genai
          import PyPDF2
          import requests
          from pathlib import Path
          
          # Configure Gemini API
          genai.configure(api_key=os.environ["GEMINI_API_KEY"])
          
          # Get scan results
          scan_results = json.loads(os.environ["SCAN_RESULTS"])
          
          # Read prompt file
          with open("AI_PROMPT_MARKDOWN_CONVERT.md", "r") as f:
              ai_prompt = f.read()
          
          # Define models to try
          models = ["gemini-2.0-flash", "gemini-2.0-flash-lite"]
          
          # Process each PDF file that passed the security scan
          for file_name, file_info in scan_results.items():
              if not file_info.get("is_clean", False):
                  print(f"Skipping {file_name} as it did not pass security scan")
                  continue
              
              pdf_path = file_info["path"]
              print(f"Processing clean PDF: {pdf_path}")
              
              # Determine output path for markdown file
              pdf_dir = os.path.dirname(pdf_path)
              markdown_dir = pdf_dir.replace("Annual Security Reports", "Markdown Conversions")
              os.makedirs(markdown_dir, exist_ok=True)
              
              markdown_filename = os.path.splitext(file_name)[0] + ".md"
              markdown_path = os.path.join(markdown_dir, markdown_filename)
              
              # Extract PDF text
              try:
                  with open(pdf_path, "rb") as f:
                      pdf_reader = PyPDF2.PdfReader(f)
                      pdf_text = ""
                      for page in pdf_reader.pages:
                          pdf_text += page.extract_text() + "\n\n"
              except Exception as e:
                  print(f"Error reading PDF {pdf_path}: {e}")
                  continue
              
              # Try models in order
              success = False
              used_model = None
              
              for model_name in models:
                  try:
                      print(f"Trying model: {model_name}")
                      model = genai.GenerativeModel(model_name)
                      
                      # Create prompt with PDF content
                      full_prompt = f"{ai_prompt}\n\nHere is the PDF content to convert to Markdown:\n\n{pdf_text}"
                      
                      # Generate markdown
                      response = model.generate_content(full_prompt)
                      
                      if response.text:
                          # Save markdown file
                          os.makedirs(os.path.dirname(markdown_path), exist_ok=True)
                          with open(markdown_path, "w") as f:
                              f.write(response.text)
                          
                          print(f"Successfully converted {pdf_path} to {markdown_path} using {model_name}")
                          used_model = model_name
                          success = True
                          break
                      else:
                          print(f"Empty response from {model_name}, trying next model")
                  
                  except Exception as e:
                      print(f"Error with {model_name} for {pdf_path}: {e}")
                      time.sleep(2)  # Wait before trying the next model
              
              if success:
                  # Commit the markdown file
                  prompt_version = "${{ steps.get-prompt-version.outputs.prompt_version }}"
                  commit_message = f"AI Prompt {prompt_version} Model {used_model.replace('-', ' ').title()}"
                  
                  os.system(f'git config --local user.email "action@github.com"')
                  os.system(f'git config --local user.name "GitHub Action"')
                  os.system(f'git add "{markdown_path}"')
                  os.system(f'git commit -m "{commit_message}"')
                  
                  # Push changes using the token
                  token = os.environ.get("REPO_ACCESS_TOKEN")
                  repo = os.environ.get("GITHUB_REPOSITORY")
                  branch = os.environ.get("GITHUB_REF_NAME")
                  
                  if token:
                      os.system(f'git push https://x-access-token:{token}@github.com/{repo}.git HEAD:{branch}')
                      print(f"Pushed markdown file to the repository with message: {commit_message}")
                  else:
                      print("REPO_ACCESS_TOKEN not available, skipping push")
              else:
                  print(f"Failed to convert {pdf_path} with any model")
          sys.exit(0)
        shell: python

      - name: Commit and push changes
        if: ${{ success() && needs.pdf_detection.outputs.is_owner == 'true' }}
        env:
          REPO_ACCESS_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
        run: |
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          
          # Push using token authentication
          if [ -n "$REPO_ACCESS_TOKEN" ]; then
            git push https://x-access-token:${REPO_ACCESS_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:${GITHUB_REF_NAME}
          else
            echo "::warning::No REPO_ACCESS_TOKEN provided, skipping push"
          fi

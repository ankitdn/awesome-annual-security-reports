name: PDF Processing Workflow

on:
  push:
    branches:
      - main
      - development
    paths:
      - 'Annual Security Reports/**/*.pdf'

jobs:
  detect-pdfs:
    name: Detect New PDF Files
    runs-on: ubuntu-latest
    outputs:
      pdf_files: ${{ steps.find-pdfs.outputs.pdf_files }}
      changes_detected: ${{ steps.find-pdfs.outputs.changes_detected }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Find changed PDF files
        id: find-pdfs
        run: |
          CHANGED_FILES=$(git diff --name-only --diff-filter=A HEAD^ HEAD | grep -E "Annual Security Reports/.*\.pdf$" || echo "")
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No new PDF files detected"
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "pdf_files=[]" >> $GITHUB_OUTPUT
          else
            echo "New PDF files detected: $CHANGED_FILES"
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            PDF_JSON="[$(echo "$CHANGED_FILES" | sed 's/^/"/;s/$/"/' | paste -sd "," -)]"
            echo "pdf_files=$PDF_JSON" >> $GITHUB_OUTPUT
          fi

  falcon-scan:
    name: Scan PDFs with Falcon Hybrid Analysis
    needs: detect-pdfs
    if: ${{ needs.detect-pdfs.outputs.changes_detected == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests mimetypes
      
      - name: Create API key file
        run: |
          echo "${{ secrets.HYBRID_ANALYSIS_API_KEY }}" > falcon.txt
      
      - name: Scan PDFs with Falcon
        id: scan-pdfs
        env:
          PDF_FILES: ${{ needs.detect-pdfs.outputs.pdf_files }}
        run: |
          echo "::group::Starting Falcon Scan"
          python - <<'EOF'
          import os
          import sys
          import json
          import requests
          import time
          import logging
          import mimetypes
          
          # Configure logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s'
          )
          
          def read_api_key(filename="falcon.txt"):
              try:
                  file_path = os.path.abspath(filename)
                  logging.info(f"Reading API key from: {file_path}")
                  
                  with open(file_path, 'r') as f:
                      api_key = f.read().strip()
                      if not api_key:
                          logging.error(f"API key file is empty")
                          sys.exit(1)
                      logging.info(f"API key found. Length: {len(api_key)} characters")
                      return api_key
              except Exception as e:
                  logging.error(f"Error reading API key: {str(e)}")
                  sys.exit(1)
          
          def submit_file(file_path, api_key):
              logging.info(f"Submitting file: {file_path}")
              
              # Verify file exists and check size
              file_size = os.path.getsize(file_path)
              logging.info(f"File size: {file_size} bytes ({file_size / (1024*1024):.2f} MB)")
              
              url = "https://www.hybrid-analysis.com/api/v2/submit/file"
              logging.info(f"API endpoint: {url}")
              
              headers = {
                  "api-key": api_key,
                  "User-Agent": "Hybrid Analysis Script",
                  "Accept": "application/json"
              }
              
              # Check file content type
              mime_type = mimetypes.guess_type(file_path)[0]
              logging.info(f"File MIME type: {mime_type}")
              
              with open(file_path, 'rb') as f:
                  files = {'file': (os.path.basename(file_path), f)}
                  
                  data = {
                      "environment_id": "110",  # Windows 10 64-bit
                      "comment": "Submitted via GitHub Action for analysis"
                  }
                  
                  try:
                      logging.info("Sending API request...")
                      response = requests.post(url, headers=headers, files=files, data=data)
                      logging.info(f"Response status code: {response.status_code}")
                      
                      response.raise_for_status()
                      return response.json()
                  except requests.exceptions.RequestException as e:
                      logging.error(f"Error submitting file: {e}")
                      if hasattr(e, 'response') and e.response:
                          try:
                              err_json = e.response.json()
                              logging.error(f"Error details: {json.dumps(err_json)}")
                          except json.JSONDecodeError:
                              logging.error(f"Error response: {e.response.text}")
                      
                      # Try with a different API endpoint structure - quick scan
                      alt_url = "https://www.hybrid-analysis.com/api/v2/quick-scan/file"
                      logging.info(f"Trying alternative API endpoint: {alt_url}")
                      
                      try:
                          with open(file_path, 'rb') as alt_f:
                              alt_data = {"scan_type": "all"}
                              response = requests.post(alt_url, headers=headers, files={'file': (os.path.basename(file_path), alt_f)}, data=alt_data)
                              logging.info(f"Alternative response status code: {response.status_code}")
                              
                              if response.status_code == 200:
                                  return response.json()
                              else:
                                  logging.error(f"Alternative endpoint failed: {response.text}")
                      except Exception as alt_e:
                          logging.error(f"Alternative endpoint error: {alt_e}")
                          
                      # Try one more time with submit/file-for-analysis endpoint
                      try:
                          third_url = "https://www.hybrid-analysis.com/api/v2/submit/file-for-analysis"
                          logging.info(f"Trying third API endpoint: {third_url}")
                          with open(file_path, 'rb') as third_f:
                              third_data = {
                                  "environment_id": "110",  # Windows 10 64-bit
                                  "analysis_type": "file",
                                  "priority": "0"
                              }
                              
                              response = requests.post(third_url, headers=headers, files={'file': (os.path.basename(file_path), third_f)}, data=third_data)
                              logging.info(f"Third endpoint response status code: {response.status_code}")
                              
                              if response.status_code == 200:
                                  return response.json()
                              else:
                                  logging.error(f"Third endpoint failed: {response.text}")
                      except Exception as third_e:
                          logging.error(f"Third endpoint error: {third_e}")
                  
                  return None
          
          def check_report_status(job_id, api_key):
              url = f"https://www.hybrid-analysis.com/api/v2/report/{job_id}/summary"
              
              headers = {
                  "api-key": api_key,
                  "User-Agent": "Hybrid Analysis Script",
                  "Accept": "application/json"
              }
              
              try:
                  response = requests.get(url, headers=headers)
                  
                  if response.status_code != 200:
                      return None
                  
                  return response.json()
              except requests.exceptions.RequestException:
                  return None
          
          # Get list of PDF files and process each one
          pdf_files_json = os.environ.get('PDF_FILES')
          pdf_files = json.loads(pdf_files_json)
          
          # Read API key
          api_key = read_api_key()
          
          scan_results = {}
          
          # Test API connectivity
          test_url = "https://www.hybrid-analysis.com/api/v2/key/current"
          logging.info("Testing API connectivity")
          try:
              headers = {
                  "api-key": api_key,
                  "User-Agent": "Hybrid Analysis Script",
                  "Accept": "application/json"
              }
              response = requests.get(test_url, headers=headers)
              if response.status_code == 200:
                  api_info = response.json()
                  logging.info(f"API key is valid. Quota remaining: {api_info.get('quota_remaining', 'unknown')}")
              else:
                  logging.warning(f"API test failed with status {response.status_code}")
          except Exception as e:
              logging.warning(f"API connection test failed: {e}")
          
          for pdf_file in pdf_files:
              try:
                  logging.info(f"Processing: {pdf_file}")
                  
                  # Submit file for analysis
                  submission = submit_file(pdf_file, api_key)
                  
                  if not submission:
                      logging.error("Failed to get response from submission API.")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": "Failed to get response from submission API",
                          "is_malicious": False
                      }
                      continue
                      
                  # Get job_id or alternative ID
                  if 'job_id' not in submission:
                      logging.warning("Failed to get job ID from submission.")
                      
                      # Check for alternative IDs or SHA256
                      if 'sha256' in submission:
                          logging.info(f"SHA256 hash found: {submission['sha256']}")
                          file_hash = submission['sha256']
                          result_url = f"https://www.hybrid-analysis.com/sample/{file_hash}"
                          
                      if 'scan_id' in submission:
                          job_id = submission['scan_id']
                          logging.info(f"Using scan_id as job_id for polling: {job_id}")
                      else:
                          scan_results[pdf_file] = {
                              "success": False,
                              "error": "Failed to get job ID from submission",
                              "is_malicious": False,
                              "sha256": submission.get('sha256', '')
                          }
                          continue
                  else:
                      job_id = submission['job_id']
                      logging.info(f"File submitted successfully. Job ID: {job_id}")
                  
                  # Poll for results
                  logging.info("Waiting for analysis to complete...")
                  max_attempts = 20
                  attempt = 0
                  
                  while attempt < max_attempts:
                      attempt += 1
                      time.sleep(15)  # Wait 15 seconds between status checks
                      
                      report = check_report_status(job_id, api_key)
                      
                      if not report:
                          logging.info(f"Polling attempt {attempt}/{max_attempts}...")
                          continue
                      
                      status = report.get('state', '')
                      
                      if status == 'SUCCESS':
                          logging.info("Analysis complete!")
                          
                          # Check for threats
                          threat_score = report.get('threat_score', 0)
                          verdict = report.get('verdict', 'Unknown')
                          
                          logging.info(f"Threat Score: {threat_score}/100")
                          logging.info(f"Verdict: {verdict}")
                          
                          # Store result
                          is_malicious = verdict.lower() in ['malicious', 'suspicious'] or threat_score > 50
                          
                          if 'sha256' in report:
                              file_hash = report['sha256']
                              result_url = f"https://www.hybrid-analysis.com/sample/{file_hash}"
                          else:
                              file_hash = submission.get('sha256', '')
                              result_url = f"https://www.hybrid-analysis.com/sample/{file_hash}" if file_hash else ''
                          
                          scan_results[pdf_file] = {
                              "success": True,
                              "job_id": job_id,
                              "result_url": result_url,
                              "is_malicious": is_malicious,
                              "verdict": verdict,
                              "threat_score": threat_score,
                              "file_hash": file_hash
                          }
                          break
                      
                      elif status == 'ERROR':
                          error_msg = report.get('error', 'Unknown error')
                          logging.error(f"Analysis failed: {error_msg}")
                          scan_results[pdf_file] = {
                              "success": False,
                              "error": f"Analysis failed: {error_msg}",
                              "is_malicious": False
                          }
                          break
                      
                      elif status == 'IN_PROGRESS':
                          logging.info(f"Status: {status}")
                      
                      else:
                          logging.info(f"Status: {status}")
                  
                  if attempt >= max_attempts:
                      logging.warning("Timeout waiting for analysis to complete.")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": "Timeout waiting for analysis to complete",
                          "is_malicious": False,
                          "job_id": job_id
                      }
              
              except Exception as e:
                  logging.error(f"Exception processing {pdf_file}: {str(e)}")
                  scan_results[pdf_file] = {
                      "success": False,
                      "error": str(e),
                      "is_malicious": False
                  }
          
          # Save scan results to file
          with open('scan_results.json', 'w') as f:
              json.dump(scan_results, f)
          
          logging.info("Scan results saved to scan_results.json")
          EOF
          echo "::endgroup::"
      
      - name: Upload scan results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: falcon-scan-results
          path: scan_results.json
          retention-days: 30

  process-scan-results:
    name: Process Scan Results
    needs: [detect-pdfs, falcon-scan]
    runs-on: ubuntu-latest
    outputs:
      has_clean_files: ${{ steps.process-results.outputs.has_clean_files }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Download scan results
        uses: actions/download-artifact@v4
        with:
          name: falcon-scan-results
      
      - name: Setup GitHub CLI
        run: |
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y
      
      - name: Parse scan results and create issues
        id: process-results
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
        run: |
          echo "::group::Processing scan results"
          python - <<'EOF'
          import json
          import os
          import subprocess
          
          # Load scan results
          with open('scan_results.json', 'r') as f:
              scan_results = json.load(f)
          
          # Process each file
          clean_files = []
          malicious_files = []
          failed_scans = []
          
          for pdf_file, result in scan_results.items():
              print(f"Processing results for: {pdf_file}")
              
              if not result.get('success', False):
                  print(f"Scan failed for {pdf_file}: {result.get('error', 'Unknown error')}")
                  failed_scans.append({
                      'file': pdf_file,
                      'error': result.get('error', 'Unknown error')
                  })
                  continue
              
              if result.get('is_malicious', False):
                  print(f"Malicious file detected: {pdf_file}")
                  malicious_files.append({
                      'file': pdf_file,
                      'verdict': result.get('verdict', 'Unknown'),
                      'threat_score': result.get('threat_score', 0),
                      'result_url': result.get('result_url', '')
                  })
              else:
                  print(f"Clean file: {pdf_file}")
                  clean_files.append(pdf_file)
          
          # Create issues for malicious files
          for malicious_file in malicious_files:
              file_path = malicious_file['file']
              file_name = os.path.basename(file_path)
              
              issue_title = f"⚠️ Security Alert: Malicious content detected in {file_name}"
              issue_body = f"""
              ## Security Alert: Malicious Content Detected
              
              **File:** {file_path}
              **Verdict:** {malicious_file['verdict']}
              **Threat Score:** {malicious_file['threat_score']}
              
              ### Analysis Results
              The file has been flagged as potentially malicious by Falcon Hybrid Analysis.
              
              **Results URL:** {malicious_file['result_url']}
              
              ### Next Steps
              1. Do not open or execute this file
              2. Review the scan results for detailed information
              3. Consider removing this file from the repository
              """
              
              # Create GitHub issue
              issue_command = [
                  'gh', 'issue', 'create',
                  '--title', issue_title,
                  '--body', issue_body,
                  '--label', 'security-alert'
              ]
              
              try:
                  subprocess.run(issue_command, check=True, env=os.environ)
                  print(f"Created issue for malicious file: {file_path}")
              except subprocess.CalledProcessError as e:
                  print(f"Failed to create issue: {str(e)}")
          
          # Create issues for failed scans
          for failed_scan in failed_scans:
              file_path = failed_scan['file']
              file_name = os.path.basename(file_path)
              
              issue_title = f"⚠️ Scan Failed: Unable to analyze {file_name}"
              issue_body = f"""
              ## Scan Failed
              
              **File:** {file_path}
              **Error:** {failed_scan['error']}
              
              ### Next Steps
              1. Verify the file is a valid PDF
              2. Check the GitHub Actions logs for more details
              3. Retry the workflow or scan the file manually
              """
              
              # Create GitHub issue
              issue_command = [
                  'gh', 'issue', 'create',
                  '--title', issue_title,
                  '--body', issue_body,
                  '--label', 'scan-failed'
              ]
              
              try:
                  subprocess.run(issue_command, check=True, env=os.environ)
                  print(f"Created issue for failed scan: {file_path}")
              except subprocess.CalledProcessError as e:
                  print(f"Failed to create issue: {str(e)}")
          
          # Output the list of clean files for next job
          clean_files_json = json.dumps(clean_files)
          with open('clean_files.json', 'w') as f:
              f.write(clean_files_json)
          
          # Set output for next job
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"has_clean_files={'true' if clean_files else 'false'}\n")
          
          print(f"Found {len(clean_files)} clean files, {len(malicious_files)} malicious files, and {len(failed_scans)} failed scans")
          EOF
          echo "::endgroup::"
      
      - name: Upload clean files list as artifact
        uses: actions/upload-artifact@v4
        with:
          name: clean-pdf-files
          path: clean_files.json
          retention-days: 1

  gemini-conversion:
    name: Convert Clean PDFs to Markdown with Gemini
    needs: [detect-pdfs, falcon-scan, process-scan-results]
    if: ${{ needs.process-scan-results.outputs.has_clean_files == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests google-generativeai PyPDF2
      
      - name: Download clean files list
        uses: actions/download-artifact@v4
        with:
          name: clean-pdf-files
      
      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          PROMPT_FILE="AI_PROMPT_MARKDOWN_CONVERT.md"
          if [ -f "$PROMPT_FILE" ]; then
            PROMPT_VERSION=$(git log -1 --pretty=format:'%s' -- "$PROMPT_FILE" | grep -o 'V[0-9]\+\.[0-9]\+' || echo 'V1.0')
            echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT
          else
            echo "prompt_version=V1.0" >> $GITHUB_OUTPUT
          fi
      
      - name: Convert PDFs to Markdown with Gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PROMPT_VERSION: ${{ steps.get-prompt-version.outputs.prompt_version }}
        run: |
          echo "::group::Converting PDFs to Markdown"
          python - <<'EOF'
          import json
          import os
          import google.generativeai as genai
          import PyPDF2
          import time
          import re
          import subprocess
          
          # Load clean files
          with open('clean_files.json', 'r') as f:
              clean_files = json.load(f)
          
          # Configure Gemini API
          gemini_api_key = os.environ.get('GEMINI_API_KEY')
          genai.configure(api_key=gemini_api_key)
          
          # Load the AI prompt
          prompt_file = "AI_PROMPT_MARKDOWN_CONVERT.md"
          with open(prompt_file, 'r') as f:
              ai_prompt = f.read()
          
          # Get prompt version
          prompt_version = os.environ.get('PROMPT_VERSION', 'V1.0')
          
          # Function to extract text from PDF
          def extract_text_from_pdf(pdf_path):
              try:
                  with open(pdf_path, 'rb') as file:
                      reader = PyPDF2.PdfReader(file)
                      text = ""
                      for page in reader.pages:
                          text += page.extract_text() + "\n\n"
                      return text
              except Exception as e:
                  print(f"Error extracting text from PDF {pdf_path}: {str(e)}")
                  return None
          
          # Function to convert text to markdown using Gemini
          def convert_to_markdown(text, model_name="gemini-2.0-flash"):
              try:
                  safety_settings = [
                      {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
                  ]
                  
                  model = genai.GenerativeModel(model_name=model_name, safety_settings=safety_settings)
                  full_prompt = f"{ai_prompt}\n\nHere is the PDF content to convert:\n\n{text}"
                  response = model.generate_content(full_prompt)
                  
                  if hasattr(response, 'text'):
                      return response.text
                  else:
                      print(f"Unexpected response format: {response}")
                      return None
              except Exception as e:
                  print(f"Error converting to markdown with {model_name}: {str(e)}")
                  return None
          
          # Process each clean file
          for pdf_file in clean_files:
              try:
                  print(f"Processing {pdf_file}")
                  
                  # Extract text from PDF
                  pdf_text = extract_text_from_pdf(pdf_file)
                  if not pdf_text:
                      print(f"Failed to extract text from {pdf_file}")
                      continue
                  
                  # First try with flash model
                  print(f"Converting with gemini-2.0-flash...")
                  markdown_content = convert_to_markdown(pdf_text, "gemini-2.0-flash")
                  model_used = "gemini-2.0-flash"
                  
                  # Fall back to flash-lite if needed
                  if not markdown_content:
                      print(f"Falling back to gemini-2.0-flash-lite...")
                      markdown_content = convert_to_markdown(pdf_text, "gemini-2.0-flash-lite")
                      model_used = "gemini-2.0-flash-lite"
                  
                  if not markdown_content:
                      print(f"Failed to convert {pdf_file} to markdown")
                      continue
                  
                  # Determine output path
                  output_path = pdf_file.replace('Annual Security Reports', 'Markdown Conversions')
                  output_path = re.sub(r'\.pdf$', '.md', output_path)
                  
                  # Create directory if it doesn't exist
                  os.makedirs(os.path.dirname(output_path), exist_ok=True)
                  
                  # Write markdown content to file
                  with open(output_path, 'w') as f:
                      f.write(markdown_content)
                  
                  print(f"Saved markdown to {output_path}")
                  
                  # Commit the file
                  commit_message = f"Convert {os.path.basename(pdf_file)} to markdown [AI Prompt {prompt_version} Model {model_used}]"
                  
                  # Stage and commit the file
                  subprocess.run(['git', 'add', output_path], check=True)
                  subprocess.run(['git', 'config', 'user.name', 'GitHub Action'], check=True)
                  subprocess.run(['git', 'config', 'user.email', 'action@github.com'], check=True)
                  subprocess.run(['git', 'commit', '-m', commit_message], check=True)
                  
                  # Push changes
                  push_attempt = 0
                  max_attempts = 3
                  
                  while push_attempt < max_attempts:
                      try:
                          subprocess.run(['git', 'pull', '--rebase'], check=True)
                          subprocess.run(['git', 'push'], check=True)
                          print(f"Successfully pushed {output_path}")
                          break
                      except subprocess.CalledProcessError as e:
                          push_attempt += 1
                          print(f"Push attempt {push_attempt} failed: {str(e)}")
                          if push_attempt >= max_attempts:
                              print(f"Failed to push after {max_attempts} attempts")
                          else:
                              print(f"Waiting before retry...")
                              time.sleep(5)
              
              except Exception as e:
                  print(f"Error processing {pdf_file}: {str(e)}")
          
          print("PDF conversion complete")
          EOF
          echo "::endgroup::"

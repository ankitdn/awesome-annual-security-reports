name: PDF Processing Workflow

on:
  push:
    branches:
      - main
      - development
    paths:
      - 'Annual Security Reports/**/*.pdf'

jobs:
  detect-pdfs:
    name: Detect New PDF Files
    runs-on: ubuntu-latest
    outputs:
      pdf_files: ${{ steps.find-pdfs.outputs.pdf_files }}
      changes_detected: ${{ steps.find-pdfs.outputs.changes_detected }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits to detect changes
      
      - name: Find changed PDF files
        id: find-pdfs
        run: |
          # Get list of PDF files added in this commit
          CHANGED_FILES=$(git diff --name-only --diff-filter=A HEAD^ HEAD | grep -E "Annual Security Reports/.*\.pdf$" || echo "")
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No new PDF files detected"
            echo "changes_detected=false" >> $GITHUB_OUTPUT
            echo "pdf_files=[]" >> $GITHUB_OUTPUT
          else
            echo "New PDF files detected: $CHANGED_FILES"
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            
            # Convert the list to JSON array for output
            PDF_JSON="[$(echo "$CHANGED_FILES" | sed 's/^/"/;s/$/"/' | paste -sd "," -)]"
            echo "pdf_files=$PDF_JSON" >> $GITHUB_OUTPUT
          fi
      
      - name: Log detection results
        run: |
          echo "Changes detected: ${{ steps.find-pdfs.outputs.changes_detected }}"
          echo "PDF files: ${{ steps.find-pdfs.outputs.pdf_files }}"

  falcon-scan:
    name: Scan PDFs with Falcon Hybrid Analysis
    needs: detect-pdfs
    if: ${{ needs.detect-pdfs.outputs.changes_detected == 'true' }}
    runs-on: ubuntu-latest
    
    outputs:
      scan_results: ${{ steps.process-results.outputs.scan_results }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests
      
      - name: Scan PDFs with Falcon
        id: scan-pdfs
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
          PDF_FILES: ${{ needs.detect-pdfs.outputs.pdf_files }}
        run: |
          echo "::group::Starting Falcon Scan"
          python - <<'EOF'
          import os
          import json
          import requests
          import time
          import base64
          import hashlib
          
          # Get list of PDF files
          pdf_files_json = os.environ.get('PDF_FILES')
          pdf_files = json.loads(pdf_files_json)
          api_key = os.environ.get('HYBRID_ANALYSIS_API_KEY')
          
          scan_results = {}
          
          for pdf_file in pdf_files:
              try:
                  print(f"Processing: {pdf_file}")
                  
                  # Check if file exists
                  if not os.path.exists(pdf_file):
                      print(f"Error: File {pdf_file} does not exist")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": "File does not exist",
                          "is_malicious": False
                      }
                      continue
                  
                  # Calculate file hash for tracking
                  with open(pdf_file, 'rb') as f:
                      file_content = f.read()
                      file_hash = hashlib.sha256(file_content).hexdigest()
                  
                  # Submit file for scanning
                  headers = {
                      'api-key': api_key,
                      'User-Agent': 'Falcon Sandbox'
                  }
                  
                  # Get file size
                  file_size = os.path.getsize(pdf_file)
                  print(f"File size: {file_size} bytes")
                  
                  # Prepare the file for upload
                  files = {
                      'file': (os.path.basename(pdf_file), open(pdf_file, 'rb'), 'application/pdf')
                  }
                  
                  # Set environment to Windows 11 64-bit
                  data = {
                      'environment_id': 300,  # Windows 11 64-bit
                      'comment': f"GitHub Action - Automatic scan of {pdf_file}"
                  }
                  
                  # Submit the file
                  print(f"Submitting {pdf_file} to Falcon Hybrid Analysis...")
                  submit_response = requests.post(
                      'https://www.hybrid-analysis.com/api/v2/submit/file',
                      headers=headers,
                      files=files,
                      data=data
                  )
                  
                  if submit_response.status_code != 200:
                      print(f"Error submitting file: {submit_response.text}")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": f"API Error: {submit_response.text}",
                          "is_malicious": False
                      }
                      continue
                  
                  submit_data = submit_response.json()
                  if not submit_data.get('success', False):
                      print(f"Submission unsuccessful: {submit_data}")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": f"Submission Error: {submit_data.get('message', 'Unknown error')}",
                          "is_malicious": False
                      }
                      continue
                  
                  job_id = submit_data.get('job_id')
                  if not job_id:
                      print("No job ID returned")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": "No job ID returned",
                          "is_malicious": False
                      }
                      continue
                  
                  print(f"Job ID: {job_id}")
                  
                  # Poll for scan results
                  max_polls = 30  # Maximum number of poll attempts
                  poll_interval = 20  # Time between polls in seconds
                  
                  result_url = None
                  for poll in range(max_polls):
                      print(f"Polling for results (attempt {poll+1}/{max_polls})...")
                      
                      state_response = requests.get(
                          f'https://www.hybrid-analysis.com/api/v2/report/{job_id}/state',
                          headers=headers
                      )
                      
                      if state_response.status_code != 200:
                          print(f"Error checking job state: {state_response.text}")
                          time.sleep(poll_interval)
                          continue
                      
                      state_data = state_response.json()
                      state = state_data.get('state', '')
                      
                      if state == 'SUCCESS':
                          # Get the report
                          report_response = requests.get(
                              f'https://www.hybrid-analysis.com/api/v2/report/{job_id}/summary',
                              headers=headers
                          )
                          
                          if report_response.status_code != 200:
                              print(f"Error getting report: {report_response.text}")
                              scan_results[pdf_file] = {
                                  "success": False,
                                  "error": f"Report retrieval error: {report_response.text}",
                                  "is_malicious": False
                              }
                              break
                          
                          report_data = report_response.json()
                          
                          # Get result URL
                          result_url = f"https://www.hybrid-analysis.com/sample/{file_hash}"
                          
                          # Check if malicious
                          verdict = report_data.get('verdict', '')
                          is_malicious = verdict.lower() in ['malicious', 'suspicious']
                          
                          scan_results[pdf_file] = {
                              "success": True,
                              "job_id": job_id,
                              "result_url": result_url,
                              "is_malicious": is_malicious,
                              "verdict": verdict,
                              "threat_score": report_data.get('threat_score', 0),
                              "threat_level": report_data.get('threat_level', 0),
                              "file_hash": file_hash
                          }
                          
                          print(f"Scan completed with verdict: {verdict}")
                          print(f"Result URL: {result_url}")
                          break
                      
                      elif state == 'ERROR' or state == 'FAILED':
                          print(f"Job failed with state: {state}")
                          scan_results[pdf_file] = {
                              "success": False,
                              "error": f"Job failed with state: {state}",
                              "is_malicious": False
                          }
                          break
                      
                      print(f"Current state: {state}, waiting {poll_interval} seconds...")
                      time.sleep(poll_interval)
                  
                  if poll >= max_polls - 1 and not result_url:
                      print("Timed out waiting for scan results")
                      scan_results[pdf_file] = {
                          "success": False,
                          "error": "Timed out waiting for scan results",
                          "is_malicious": False,
                          "job_id": job_id
                      }
              
              except Exception as e:
                  print(f"Exception processing {pdf_file}: {str(e)}")
                  scan_results[pdf_file] = {
                      "success": False,
                      "error": str(e),
                      "is_malicious": False
                  }
          
          # Save scan results to file (excluding any sensitive info)
          with open('scan_results.json', 'w') as f:
              json.dump(scan_results, f)
          
          print("Scan results saved to scan_results.json")
          EOF
          echo "::endgroup::"
      
      - name: Process and output scan results
        id: process-results
        run: |
          echo "::group::Processing Scan Results"
          python - <<'EOF'
          import json
          import os
          
          with open('scan_results.json', 'r') as f:
              scan_results = json.load(f)
          
          # Clean and prepare results for output
          clean_results = {}
          for pdf_file, result in scan_results.items():
              clean_results[pdf_file] = {
                  "success": result.get("success", False),
                  "is_malicious": result.get("is_malicious", False),
                  "result_url": result.get("result_url", ""),
                  "verdict": result.get("verdict", ""),
                  "threat_score": result.get("threat_score", 0),
                  "file_hash": result.get("file_hash", "")
              }
              
              # Add error info if available
              if not result.get("success", False) and "error" in result:
                  clean_results[pdf_file]["error"] = result["error"]
          
          # Write output in GitHub Actions format
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"scan_results={json.dumps(clean_results).replace('%', '%25').replace('\n', '%0A').replace('\r', '%0D').replace(':', '%3A').replace(',', '%2C')}\n")
          
          print("Processed scan results for GitHub Actions output")
          EOF
          echo "::endgroup::"
      
      - name: Upload scan results as artifact
        uses: actions/upload-artifact@v3
        with:
          name: falcon-scan-results
          path: scan_results.json
          retention-days: 30

  process-scan-results:
    name: Process Scan Results
    needs: [detect-pdfs, falcon-scan]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Parse scan results and create issues
        env:
          SCAN_RESULTS: ${{ needs.falcon-scan.outputs.scan_results }}
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
        run: |
          echo "::group::Processing scan results"
          python - <<'EOF'
          import json
          import os
          import subprocess
          import sys
          
          # Load scan results
          scan_results_json = os.environ.get('SCAN_RESULTS', '{}')
          scan_results = json.loads(scan_results_json)
          
          # Process each file
          clean_files = []
          malicious_files = []
          failed_scans = []
          
          for pdf_file, result in scan_results.items():
              print(f"Processing results for: {pdf_file}")
              
              if not result.get('success', False):
                  print(f"Scan failed for {pdf_file}: {result.get('error', 'Unknown error')}")
                  failed_scans.append({
                      'file': pdf_file,
                      'error': result.get('error', 'Unknown error')
                  })
                  continue
              
              if result.get('is_malicious', False):
                  print(f"Malicious file detected: {pdf_file}")
                  malicious_files.append({
                      'file': pdf_file,
                      'verdict': result.get('verdict', 'Unknown'),
                      'threat_score': result.get('threat_score', 0),
                      'result_url': result.get('result_url', '')
                  })
              else:
                  print(f"Clean file: {pdf_file}")
                  clean_files.append(pdf_file)
          
          # Create issues for malicious files
          for malicious_file in malicious_files:
              file_path = malicious_file['file']
              file_name = os.path.basename(file_path)
              
              issue_title = f"⚠️ Security Alert: Malicious content detected in {file_name}"
              issue_body = f"""
              ## Security Alert: Malicious Content Detected
              
              **File:** {file_path}
              **Verdict:** {malicious_file['verdict']}
              **Threat Score:** {malicious_file['threat_score']}
              
              ### Analysis Results
              The file has been flagged as potentially malicious by Falcon Hybrid Analysis.
              
              **Results URL:** {malicious_file['result_url']}
              
              ### Next Steps
              1. Do not open or execute this file
              2. Review the scan results for detailed information
              3. Consider removing this file from the repository
              
              This issue was automatically generated by the PDF Processing workflow.
              """
              
              # Create GitHub issue
              issue_command = [
                  'gh', 'issue', 'create',
                  '--title', issue_title,
                  '--body', issue_body,
                  '--label', 'security-alert'
              ]
              
              try:
                  subprocess.run(issue_command, check=True, env=os.environ)
                  print(f"Created issue for malicious file: {file_path}")
              except subprocess.CalledProcessError as e:
                  print(f"Failed to create issue: {str(e)}")
          
          # Create issues for failed scans
          for failed_scan in failed_scans:
              file_path = failed_scan['file']
              file_name = os.path.basename(file_path)
              
              issue_title = f"⚠️ Scan Failed: Unable to analyze {file_name}"
              issue_body = f"""
              ## Scan Failed
              
              **File:** {file_path}
              **Error:** {failed_scan['error']}
              
              ### Next Steps
              1. Verify the file is a valid PDF
              2. Check the GitHub Actions logs for more details
              3. Retry the workflow or scan the file manually
              
              This issue was automatically generated by the PDF Processing workflow.
              """
              
              # Create GitHub issue
              issue_command = [
                  'gh', 'issue', 'create',
                  '--title', issue_title,
                  '--body', issue_body,
                  '--label', 'scan-failed'
              ]
              
              try:
                  subprocess.run(issue_command, check=True, env=os.environ)
                  print(f"Created issue for failed scan: {file_path}")
              except subprocess.CalledProcessError as e:
                  print(f"Failed to create issue: {str(e)}")
          
          # Output the list of clean files for next job
          clean_files_json = json.dumps(clean_files)
          with open('clean_files.json', 'w') as f:
              f.write(clean_files_json)
          
          # Set output for next job
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"clean_files={clean_files_json.replace('%', '%25').replace('\n', '%0A').replace('\r', '%0D').replace(':', '%3A').replace(',', '%2C')}\n")
              f.write(f"has_clean_files={'true' if clean_files else 'false'}\n")
          
          print(f"Found {len(clean_files)} clean files, {len(malicious_files)} malicious files, and {len(failed_scans)} failed scans")
          EOF
          echo "::endgroup::"
      
      - name: Setup GitHub CLI
        uses: cli/cli-action@v1
      
      - name: Upload clean files list as artifact
        uses: actions/upload-artifact@v3
        with:
          name: clean-pdf-files
          path: clean_files.json
          retention-days: 1

  gemini-conversion:
    name: Convert Clean PDFs to Markdown with Gemini
    needs: [detect-pdfs, falcon-scan, process-scan-results]
    if: ${{ needs.process-scan-results.outputs.has_clean_files == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests google-generativeai PyPDF2
      
      - name: Download clean files list
        uses: actions/download-artifact@v3
        with:
          name: clean-pdf-files
      
      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          PROMPT_FILE="AI_PROMPT_MARKDOWN_CONVERT.md"
          if [ -f "$PROMPT_FILE" ]; then
            PROMPT_VERSION=$(git log -1 --pretty=format:'%s' -- "$PROMPT_FILE" | grep -o 'V[0-9]\+\.[0-9]\+' || echo 'V1.0')
            echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT
            echo "Prompt version: $PROMPT_VERSION"
          else
            echo "prompt_version=V1.0" >> $GITHUB_OUTPUT
            echo "Prompt file not found, using default version V1.0"
          fi
      
      - name: Convert PDFs to Markdown with Gemini
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PROMPT_VERSION: ${{ steps.get-prompt-version.outputs.prompt_version }}
        run: |
          echo "::group::Converting PDFs to Markdown"
          python - <<'EOF'
          import json
          import os
          import requests
          import google.generativeai as genai
          import PyPDF2
          import time
          import re
          import subprocess
          
          # Load clean files
          with open('clean_files.json', 'r') as f:
              clean_files = json.load(f)
          
          # Configure Gemini API
          gemini_api_key = os.environ.get('GEMINI_API_KEY')
          genai.configure(api_key=gemini_api_key)
          
          # Load the AI prompt
          prompt_file = "AI_PROMPT_MARKDOWN_CONVERT.md"
          with open(prompt_file, 'r') as f:
              ai_prompt = f.read()
          
          # Get prompt version
          prompt_version = os.environ.get('PROMPT_VERSION', 'V1.0')
          
          # Function to extract text from PDF
          def extract_text_from_pdf(pdf_path):
              try:
                  with open(pdf_path, 'rb') as file:
                      reader = PyPDF2.PdfReader(file)
                      text = ""
                      for page in reader.pages:
                          text += page.extract_text() + "\n\n"
                      return text
              except Exception as e:
                  print(f"Error extracting text from PDF {pdf_path}: {str(e)}")
                  return None
          
          # Function to convert text to markdown using Gemini
          def convert_to_markdown(text, model_name="gemini-1.5-flash"):
              try:
                  safety_settings = [
                      {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                      {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
                  ]
                  
                  model = genai.GenerativeModel(model_name=model_name, safety_settings=safety_settings)
                  
                  # Construct prompt with extracted text
                  full_prompt = f"{ai_prompt}\n\nHere is the PDF content to convert:\n\n{text}"
                  
                  response = model.generate_content(full_prompt)
                  
                  if hasattr(response, 'text'):
                      return response.text
                  else:
                      print(f"Unexpected response format: {response}")
                      return None
              except Exception as e:
                  print(f"Error converting to markdown with {model_name}: {str(e)}")
                  return None
          
          # Process each clean file
          for pdf_file in clean_files:
              try:
                  print(f"Processing {pdf_file}")
                  
                  # Extract text from PDF
                  pdf_text = extract_text_from_pdf(pdf_file)
                  if not pdf_text:
                      print(f"Failed to extract text from {pdf_file}")
                      continue
                  
                  # First try with flash model
                  print(f"Converting with gemini-2.0-flash...")
                  markdown_content = convert_to_markdown(pdf_text, "gemini-2.0-flash")
                  model_used = "gemini-2.0-flash"
                  
                  # Fall back to flash-lite if needed
                  if not markdown_content:
                      print(f"Falling back to gemini-2.0-flash-lite...")
                      markdown_content = convert_to_markdown(pdf_text, "gemini-2.0-flash-lite")
                      model_used = "gemini-2.0-flash-lite"
                  
                  if not markdown_content:
                      print(f"Failed to convert {pdf_file} to markdown")
                      continue
                  
                  # Determine output path
                  # Replace 'Annual Security Reports' with 'Markdown Conversions' in the path
                  output_path = pdf_file.replace('Annual Security Reports', 'Markdown Conversions')
                  output_path = re.sub(r'\.pdf$', '.md', output_path)
                  
                  # Create directory if it doesn't exist
                  os.makedirs(os.path.dirname(output_path), exist_ok=True)
                  
                  # Write markdown content to file
                  with open(output_path, 'w') as f:
                      f.write(markdown_content)
                  
                  print(f"Saved markdown to {output_path}")
                  
                  # Commit the file
                  commit_message = f"Convert {os.path.basename(pdf_file)} to markdown [AI Prompt {prompt_version} Model {model_used}]"
                  
                  # Stage and commit the file
                  subprocess.run(['git', 'add', output_path], check=True)
                  subprocess.run(['git', 'config', 'user.name', 'GitHub Action'], check=True)
                  subprocess.run(['git', 'config', 'user.email', 'action@github.com'], check=True)
                  subprocess.run(['git', 'commit', '-m', commit_message], check=True)
                  
                  # Push changes
                  push_attempt = 0
                  max_attempts = 3
                  
                  while push_attempt < max_attempts:
                      try:
                          subprocess.run(['git', 'pull', '--rebase'], check=True)
                          subprocess.run(['git', 'push'], check=True)
                          print(f"Successfully pushed {output_path}")
                          break
                      except subprocess.CalledProcessError as e:
                          push_attempt += 1
                          print(f"Push attempt {push_attempt} failed: {str(e)}")
                          if push_attempt >= max_attempts:
                              print(f"Failed to push after {max_attempts} attempts")
                          else:
                              print(f"Waiting before retry...")
                              time.sleep(5)
              
              except Exception as e:
                  print(f"Error processing {pdf_file}: {str(e)}")
          
          print("PDF conversion complete")
          EOF
          echo "::endgroup::"

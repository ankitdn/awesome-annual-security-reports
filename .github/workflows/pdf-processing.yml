name: PDF Processing Workflow

on:
  push:
    branches: [main, development]
    paths:
      - 'Annual Security Reports/**/*.pdf'

jobs:
  detect-pdf-files:
    name: Detect New PDF Files
    runs-on: ubuntu-latest
    outputs:
      pdf_files: ${{ steps.find-pdfs.outputs.pdf_files }}
      pdf_count: ${{ steps.find-pdfs.outputs.pdf_count }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2  # To get current and previous commit
      
      - name: Find changed PDF files
        id: find-pdfs
        run: |
          # Get list of added or modified PDF files from the Annual Security Reports directory
          CHANGED_FILES=$(git diff --name-status HEAD^ HEAD | grep -E '^[AM].*Annual Security Reports.*\.pdf$' | cut -f2-)
          
          # If no files were found, check if this is the first commit
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed PDFs detected in regular diff, checking if this is first commit..."
            # For first commit, list all PDFs
            if [ $(git rev-list --count HEAD) -eq 1 ]; then
              CHANGED_FILES=$(find "Annual Security Reports" -name "*.pdf")
            fi
          fi
          
          # Filter to only include added (not deleted) PDFs
          if [ -n "$CHANGED_FILES" ]; then
            # Convert newline-separated list to JSON array
            PDF_FILES=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            PDF_COUNT=$(echo "$PDF_FILES" | jq 'length')
            
            echo "Found $PDF_COUNT PDF files: $PDF_FILES"
            echo "pdf_files=$PDF_FILES" >> $GITHUB_OUTPUT
            echo "pdf_count=$PDF_COUNT" >> $GITHUB_OUTPUT
          else
            echo "No new PDF files detected"
            echo "pdf_files=[]" >> $GITHUB_OUTPUT
            echo "pdf_count=0" >> $GITHUB_OUTPUT
          fi
      
      - name: Log detection results
        run: |
          echo "Detected PDFs: ${{ steps.find-pdfs.outputs.pdf_count }}"
          echo "PDF list: ${{ steps.find-pdfs.outputs.pdf_files }}"

  scan-with-falcon:
    name: Scan with Falcon Hybrid Analysis
    needs: detect-pdf-files
    if: ${{ needs.detect-pdf-files.outputs.pdf_count > 0 }}
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        pdf_file: ${{ fromJson(needs.detect-pdf-files.outputs.pdf_files) }}
      max-parallel: 3  # Limit parallel API calls to avoid rate limiting
    
    outputs:
      scan_results: ${{ steps.collect-results.outputs.scan_results }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      - name: Upload to Falcon Hybrid Analysis
        id: upload-to-falcon
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
          PDF_FILE: ${{ matrix.pdf_file }}
        run: |
          echo "Processing file: $PDF_FILE"
          
          # Upload file to Hybrid Analysis
          UPLOAD_RESPONSE=$(curl -X POST \
            -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
            -H "Content-Type: multipart/form-data" \
            -H "User-Agent: Falcon Sandbox" \
            -F "file=@$PDF_FILE" \
            -F "environment_id=300" \
            -F "comment=PDF scan from GitHub Action" \
            "https://www.hybrid-analysis.com/api/v2/submit/file")
          
          # Parse the response without exposing the API key
          SANITIZED_RESPONSE=$(echo "$UPLOAD_RESPONSE" | grep -v "$HYBRID_ANALYSIS_API_KEY" || echo "$UPLOAD_RESPONSE")
          echo "Upload response received"
          
          # Extract job ID
          JOB_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.job_id')
          SHA256=$(echo "$UPLOAD_RESPONSE" | jq -r '.sha256')
          
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" == "null" ]; then
            echo "Failed to upload file to Falcon Hybrid Analysis"
            echo "Error: $(echo $SANITIZED_RESPONSE | jq -r '.message // "Unknown error"')"
            exit 1
          fi
          
          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "Uploaded file with job ID: $JOB_ID"

      - name: Poll scan result
        id: poll-scan
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
          JOB_ID: ${{ steps.upload-to-falcon.outputs.job_id }}
          SHA256: ${{ steps.upload-to-falcon.outputs.sha256 }}
          PDF_FILE: ${{ matrix.pdf_file }}
        run: |
          MAX_ATTEMPTS=30
          ATTEMPT=0
          SLEEP_TIME=20
          
          # Function to get scan state
          get_scan_state() {
            curl -s -X GET \
              -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
              -H "Accept: application/json" \
              "https://www.hybrid-analysis.com/api/v2/report/$SHA256/state"
          }
          
          # Poll until scan is finished or timeout
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            SCAN_STATE=$(get_scan_state)
            STATE=$(echo "$SCAN_STATE" | jq -r '.state')
            
            echo "Scan state (attempt $ATTEMPT): $STATE"
            
            # Check if scan is finished
            if [ "$STATE" == "SUCCESS" ]; then
              echo "Scan completed successfully."
              break
            fi
            
            if [ "$STATE" == "ERROR" ] || [ "$STATE" == "FAILED" ]; then
              echo "Scan failed: $(echo $SCAN_STATE | jq -r '.message // "Unknown error"')"
              exit 1
            fi
            
            # Sleep and increment attempt counter
            ATTEMPT=$((ATTEMPT + 1))
            echo "Waiting for scan to complete... ($ATTEMPT/$MAX_ATTEMPTS)"
            sleep $SLEEP_TIME
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Timeout waiting for scan to complete"
            exit 1
          fi
          
          # Get the scan results
          RESULT_RESPONSE=$(curl -s -X GET \
            -H "api-key: $HYBRID_ANALYSIS_API_KEY" \
            -H "Accept: application/json" \
            "https://www.hybrid-analysis.com/api/v2/report/$SHA256/summary")
          
          # Extract threat score and verdict
          THREAT_SCORE=$(echo "$RESULT_RESPONSE" | jq -r '.threat_score // 0')
          VERDICT=$(echo "$RESULT_RESPONSE" | jq -r '.verdict // "unknown"')
          REPORT_URL="https://www.hybrid-analysis.com/sample/$SHA256"
          
          echo "Threat score: $THREAT_SCORE"
          echo "Verdict: $VERDICT"
          echo "Report URL: $REPORT_URL"
          
          # Create a JSON object with the scan results
          FILE_NAME=$(basename "$PDF_FILE")
          SCAN_RESULT_JSON=$(jq -n \
            --arg file "$PDF_FILE" \
            --arg filename "$FILE_NAME" \
            --arg sha256 "$SHA256" \
            --arg report_url "$REPORT_URL" \
            --argjson threat_score "$THREAT_SCORE" \
            --arg verdict "$VERDICT" \
            '{file: $file, filename: $filename, sha256: $sha256, report_url: $report_url, threat_score: $threat_score, verdict: $verdict, is_malicious: ($threat_score > 50 || $verdict == "malicious")}')
          
          echo "scan_result=$SCAN_RESULT_JSON" >> $GITHUB_OUTPUT
      
      - name: Save scan results as artifact
        uses: actions/upload-artifact@v3
        with:
          name: scan-result-${{ matrix.pdf_file }}
          path: |
            echo '${{ steps.poll-scan.outputs.scan_result }}' > scan-result.json
      
      - name: Collect scan results
        id: collect-results
        run: |
          SCAN_RESULT='${{ steps.poll-scan.outputs.scan_result }}'
          echo "scan_results=$SCAN_RESULT" >> $GITHUB_OUTPUT

  process-scan-results:
    name: Process Scan Results
    needs: [detect-pdf-files, scan-with-falcon]
    runs-on: ubuntu-latest
    if: ${{ needs.detect-pdf-files.outputs.pdf_count > 0 }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Set up Git user
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
      
      - name: Download all scan results
        uses: actions/download-artifact@v3
      
      - name: Process results
        id: process-results
        run: |
          # Initialize outputs
          echo "malicious_files=[]" >> $GITHUB_OUTPUT
          echo "clean_files=[]" >> $GITHUB_OUTPUT
          
          # Process each scan result
          for result_dir in scan-result-*; do
            if [ -d "$result_dir" ]; then
              # Read the scan result file
              if [ -f "$result_dir/scan-result.json" ]; then
                RESULT=$(cat "$result_dir/scan-result.json")
                
                # Extract information
                FILE_PATH=$(echo "$RESULT" | jq -r '.file')
                IS_MALICIOUS=$(echo "$RESULT" | jq -r '.is_malicious')
                
                echo "Processing result for: $FILE_PATH (Malicious: $IS_MALICIOUS)"
                
                # Add to appropriate list
                if [ "$IS_MALICIOUS" == "true" ]; then
                  MALICIOUS_FILES=$(echo "$MALICIOUS_FILES" | jq -s '. + [{"file": "'$FILE_PATH'"}]' || echo "[$FILE_PATH]")
                  echo "malicious_files=$MALICIOUS_FILES" >> $GITHUB_OUTPUT
                else
                  CLEAN_FILES=$(echo "$CLEAN_FILES" | jq -s '. + [{"file": "'$FILE_PATH'"}]' || echo "[$FILE_PATH]")
                  echo "clean_files=$CLEAN_FILES" >> $GITHUB_OUTPUT
                fi
              fi
            fi
          done
      
      - name: Handle malicious files
        if: ${{ steps.process-results.outputs.malicious_files != '[]' }}
        run: |
          echo "Warning: Malicious files detected in scan!"
          MALICIOUS_FILES='${{ steps.process-results.outputs.malicious_files }}'
          
          # Create an issue for each malicious file
          for FILE in $(echo "$MALICIOUS_FILES" | jq -r '.[].file'); do
            echo "Creating issue for malicious file: $FILE"
            
            # Get scan details
            SCAN_RESULT=$(cat "scan-result-$FILE/scan-result.json")
            REPORT_URL=$(echo "$SCAN_RESULT" | jq -r '.report_url')
            THREAT_SCORE=$(echo "$SCAN_RESULT" | jq -r '.threat_score')
            VERDICT=$(echo "$SCAN_RESULT" | jq -r '.verdict')
            
            # Create issue using GitHub API
            curl -X POST \
              -H "Authorization: token ${{ secrets.REPO_ACCESS_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{
                \"title\": \"Security Alert: Malicious PDF Detected - $(basename "$FILE")\",
                \"body\": \"A potentially malicious PDF file was detected in the repository: \`$FILE\`\\n\\nScan Results:\\n- Threat Score: $THREAT_SCORE\\n- Verdict: $VERDICT\\n- Report URL: $REPORT_URL\\n\\nPlease review this file immediately.\",
                \"labels\": [\"security\", \"malware-alert\"]
              }" \
              "https://api.github.com/repos/${{ github.repository }}/issues"
          done

  convert-to-markdown:
    name: Convert PDF to Markdown using Gemini
    needs: [detect-pdf-files, scan-with-falcon, process-scan-results]
    if: always() && needs.detect-pdf-files.outputs.pdf_count > 0
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
      
      - name: Set up Git user
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
      
      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          PROMPT_FILE="AI_PROMPT_MARKDOWN_CONVERT.md"
          if [ -f "$PROMPT_FILE" ]; then
            # Get the last commit message for the prompt file
            PROMPT_VERSION=$(git log -1 --pretty=format:"%s" -- "$PROMPT_FILE" | grep -oE "V[0-9]+\.[0-9]+" || echo "V1.0")
            # If no version found in commit message, default to V1.0
            if [ -z "$PROMPT_VERSION" ]; then
              PROMPT_VERSION="V1.0"
            fi
          else
            PROMPT_VERSION="V1.0"
          fi
          echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT
          echo "Using AI Prompt $PROMPT_VERSION"
      
      - name: Process clean PDFs
        id: process-pdfs
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PROMPT_VERSION: ${{ steps.get-prompt-version.outputs.prompt_version }}
        run: |
          # Get list of clean files to process
          CLEAN_FILES="${{ needs.process-scan-results.outputs.clean_files }}"
          
          # If there are no clean files, exit
          if [ "$CLEAN_FILES" == "[]" ] || [ -z "$CLEAN_FILES" ]; then
            echo "No clean PDF files to process"
            exit 0
          fi
          
          # Read the AI prompt template
          AI_PROMPT=$(cat AI_PROMPT_MARKDOWN_CONVERT.md)
          
          # Process each clean file
          for FILE_JSON in $(echo "$CLEAN_FILES" | jq -c '.[]'); do
            FILE_PATH=$(echo "$FILE_JSON" | jq -r '.file')
            
            echo "Converting PDF to Markdown: $FILE_PATH"
            
            # Extract file name and year directory
            FILE_NAME=$(basename "$FILE_PATH" .pdf)
            YEAR_DIR=$(echo "$FILE_PATH" | grep -oE '202[0-9]/' | tr -d '/')
            
            if [ -z "$YEAR_DIR" ]; then
              # If year directory not found in path, try to determine it from filename or use current year
              YEAR_DIR=$(echo "$FILE_NAME" | grep -oE '202[0-9]' || date +"%Y")
            fi
            
            # Create output directory if it doesn't exist
            OUTPUT_DIR="Markdown Conversions/$YEAR_DIR"
            mkdir -p "$OUTPUT_DIR"
            
            # Define output file path
            OUTPUT_FILE="$OUTPUT_DIR/$FILE_NAME.md"
            
            # Convert PDF to base64
            PDF_BASE64=$(base64 -w 0 "$FILE_PATH")
            
            # Try with Gemini 2.0 Flash first
            echo "Attempting conversion with gemini-2.0-flash..."
            MODEL="gemini-2.0-flash"
            
            # Prepare JSON payload for Gemini API
            JSON_PAYLOAD=$(jq -n \
              --arg prompt "$AI_PROMPT" \
              --arg pdf_base64 "$PDF_BASE64" \
               '{
                 "contents": [
                   {
                     "role": "user",
                     "parts": [
                       {"text": $prompt},
                       {"inline_data": {"mime_type": "application/pdf", "data": $pdf_base64}}
                     ]
                   }
                 ],
                 "generationConfig": {
                   "temperature": 0.2,
                   "maxOutputTokens": 100000
                 }
               }')
            
            # Call Gemini API
            RESPONSE=$(curl -s -X POST \
              -H "Content-Type: application/json" \
              -H "x-goog-api-key: $GEMINI_API_KEY" \
              "https://generativelanguage.googleapis.com/v1beta/models/$MODEL:generateContent" \
              -d "$JSON_PAYLOAD")
            
            # Check if there was an error with the first model
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            # If there was an error, try with the fallback model
            if [ -n "$ERROR_MESSAGE" ]; then
              echo "Error with gemini-2.0-flash: $ERROR_MESSAGE"
              echo "Falling back to gemini-2.0-flash-lite..."
              
              MODEL="gemini-2.0-flash-lite"
              
              RESPONSE=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "x-goog-api-key: $GEMINI_API_KEY" \
                "https://generativelanguage.googleapis.com/v1beta/models/$MODEL:generateContent" \
                -d "$JSON_PAYLOAD")
              
              # Check for errors with fallback model
              ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
              
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error with fallback model: $ERROR_MESSAGE"
                echo "Failed to convert PDF. Skipping."
                continue
              fi
            fi
            
            # Extract markdown content from response
            MARKDOWN_CONTENT=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "Error: Unable to extract content"')
            
            # Save markdown content to file
            echo "$MARKDOWN_CONTENT" > "$OUTPUT_FILE"
            
            # Add and commit the file
            git add "$OUTPUT_FILE"
            git commit -m "Add markdown conversion for $FILE_NAME" -m "Processed with AI Prompt $PROMPT_VERSION Model $MODEL"
            
            echo "Successfully converted $FILE_PATH to $OUTPUT_FILE"
          done
          
          # Push all changes
          git push origin HEAD

name: PDF Processing Workflow

on:
  push:
    paths:
      - 'Annual Security Reports/**/*.pdf'
    branches:
      - main
      - development

jobs:
  detect-pdf-changes:
    name: Detect New PDF Files
    runs-on: ubuntu-latest
    outputs:
      pdf_files: ${{ steps.find-new-pdfs.outputs.pdf_files }}
      has_new_pdfs: ${{ steps.find-new-pdfs.outputs.has_new_pdfs }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Find new PDF files
        id: find-new-pdfs
        run: |
          echo "Detecting new PDF files..."
          
          # Get list of changed files in this push
          CHANGED_FILES=$(git diff --name-status HEAD^ HEAD | grep -E '^A.*\.pdf

  scan-with-falcon:
    name: Scan PDFs with Falcon Hybrid-Analysis
    needs: detect-pdf-changes
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    outputs:
      scan_results: ${{ steps.process-scan-results.outputs.scan_results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install axios form-data fs-extra

      - name: Scan PDFs with Falcon Hybrid-Analysis
        id: scan-pdfs
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
          PDF_FILES: ${{ needs.detect-pdf-changes.outputs.pdf_files }}
        run: |
          cat > scan-pdfs.js << 'EOL'
          const axios = require('axios');
          const FormData = require('form-data');
          const fs = require('fs');
          const path = require('path');
          const fsExtra = require('fs-extra');

          // Function to submit a file to Hybrid Analysis
          async function submitScan(filePath) {
            try {
              console.log(`Preparing to scan: ${filePath}`);
              
              const fileName = path.basename(filePath);
              
              // Check if file exists
              if (!fs.existsSync(filePath)) {
                console.error(`File not found: ${filePath}`);
                return { file: filePath, error: 'File not found', clean: false };
              }
              
              const form = new FormData();
              form.append('file', fs.createReadStream(filePath));
              form.append('environment_id', '300'); // Windows 11 64-bit
              form.append('scan_type', 'full');
                
              console.log(`Submitting ${fileName} to Falcon Hybrid Analysis...`);
              
              const submitResponse = await axios.post('https://www.hybrid-analysis.com/api/v2/submit/file', form, {
                headers: {
                  ...form.getHeaders(),
                  'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                  'user-agent': 'Falcon Sandbox'
                }
              });
              
              if (submitResponse.data && submitResponse.data.job_id) {
                console.log(`Submission successful for ${fileName}. Job ID: ${submitResponse.data.job_id}`);
                
                // Poll for results
                let scanComplete = false;
                let attempts = 0;
                let scanResult = null;
                
                while (!scanComplete && attempts < 20) {
                  await new Promise(resolve => setTimeout(resolve, 30000)); // Wait for 30 seconds
                  attempts++;
                  
                  try {
                    console.log(`Checking scan status for ${fileName} (attempt ${attempts})...`);
                    const statusResponse = await axios.get(`https://www.hybrid-analysis.com/api/v2/report/${submitResponse.data.job_id}/state`, {
                      headers: {
                        'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                        'user-agent': 'Falcon Sandbox'
                      }
                    });
                    
                    if (statusResponse.data && statusResponse.data.state === 'SUCCESS') {
                      console.log(`Scan complete for ${fileName}`);
                      scanComplete = true;
                      
                      // Get full report
                      const reportResponse = await axios.get(`https://www.hybrid-analysis.com/api/v2/report/${submitResponse.data.job_id}/summary`, {
                        headers: {
                          'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                          'user-agent': 'Falcon Sandbox'
                        }
                      });
                      
                      scanResult = {
                        file: filePath,
                        job_id: submitResponse.data.job_id,
                        report_url: `https://www.hybrid-analysis.com/sample/${reportResponse.data.sha256}/`,
                        verdict: reportResponse.data.verdict,
                        threat_score: reportResponse.data.threat_score,
                        malware_family: reportResponse.data.malware_family || 'None',
                        clean: reportResponse.data.verdict === 'no specific threat' || reportResponse.data.threat_score < 10
                      };
                    } else if (statusResponse.data && statusResponse.data.state === 'ERROR') {
                      console.error(`Scan error for ${fileName}: ${statusResponse.data.message || 'Unknown error'}`);
                      scanComplete = true;
                      scanResult = { 
                        file: filePath, 
                        error: statusResponse.data.message || 'Scan failed',
                        clean: false 
                      };
                    }
                  } catch (error) {
                    console.error(`Error checking scan status for ${fileName}:`, error.message);
                  }
                }
                
                if (!scanComplete) {
                  console.error(`Scan timed out for ${fileName} after ${attempts} attempts`);
                  return { 
                    file: filePath, 
                    job_id: submitResponse.data.job_id,
                    error: 'Scan timed out', 
                    clean: false 
                  };
                }
                
                return scanResult;
              } else {
                console.error(`Submission failed for ${fileName}`);
                return { 
                  file: filePath, 
                  error: 'Submission failed', 
                  clean: false 
                };
              }
            } catch (error) {
              console.error(`Error scanning ${filePath}:`, error.message);
              return { 
                file: filePath, 
                error: `Scanning error: ${error.message}`, 
                clean: false 
              };
            }
          }

          async function main() {
            try {
              const pdfFiles = JSON.parse(process.env.PDF_FILES);
              console.log(`Processing ${pdfFiles.length} PDF files`);
              
              const results = [];
              
              for (const filePath of pdfFiles) {
                const result = await submitScan(filePath);
                results.push(result);
              }
              
              // Write results to file for the next step
              fsExtra.writeJSONSync('scan_results.json', results);
              console.log('Scan results saved to scan_results.json');
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          node scan-pdfs.js

      - name: Process scan results
        id: process-scan-results
        run: |
          if [ -f "scan_results.json" ]; then
            SCAN_RESULTS=$(cat scan_results.json)
            # Escape JSON for GitHub Actions output
            SCAN_RESULTS="${SCAN_RESULTS//'%'/'%25'}"
            SCAN_RESULTS="${SCAN_RESULTS//$'\n'/'%0A'}"
            SCAN_RESULTS="${SCAN_RESULTS//$'\r'/'%0D'}"
            echo "scan_results=$SCAN_RESULTS" >> $GITHUB_OUTPUT
            
            echo "Scan results processed."
          else
            echo "Error: scan_results.json not found"
            echo "scan_results=[]" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload scan results as artifact
        uses: actions/upload-artifact@v3
        with:
          name: falcon-scan-results
          path: scan_results.json
          retention-days: 5

  create-issues-for-threats:
    name: Create Issues for Threats
    needs: [detect-pdf-changes, scan-with-falcon]
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Create issues for malicious files
        env:
          SCAN_RESULTS: ${{ needs.scan-with-falcon.outputs.scan_results }}
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
          REPO_OWNER: jacobdjwilson
          REPO_NAME: awesome-annual-security-reports
        run: |
          cat > create-issues.js << 'EOL'
          const axios = require('axios');

          async function createGitHubIssue(title, body) {
            try {
              const response = await axios.post(
                `https://api.github.com/repos/${process.env.REPO_OWNER}/${process.env.REPO_NAME}/issues`,
                {
                  title: title,
                  body: body
                },
                {
                  headers: {
                    'Authorization': `token ${process.env.GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                }
              );
              return response.data.html_url;
            } catch (error) {
              console.error('Error creating GitHub issue:', error.message);
              return null;
            }
          }

          async function main() {
            try {
              const scanResults = JSON.parse(process.env.SCAN_RESULTS);
              
              for (const result of scanResults) {
                // Create issues only for files that aren't clean
                if (result.clean === false && !result.error) {
                  const fileName = result.file.split('/').pop();
                  
                  const issueTitle = `⚠️ Security threat detected in ${fileName}`;
                  const issueBody = `
          # Security Threat Alert

          A security threat was detected in the PDF file: \`${result.file}\`

          ## Scan Details
          - **Report URL**: [Falcon Hybrid Analysis Report](${result.report_url})
          - **Verdict**: ${result.verdict}
          - **Threat Score**: ${result.threat_score}
          - **Malware Family**: ${result.malware_family || 'None'}

          Please review this file carefully before proceeding with any markdown conversion.
          `;
                  
                  console.log(`Creating issue for malicious file: ${fileName}`);
                  const issueUrl = await createGitHubIssue(issueTitle, issueBody);
                  
                  if (issueUrl) {
                    console.log(`Issue created successfully: ${issueUrl}`);
                  } else {
                    console.error(`Failed to create issue for ${fileName}`);
                  }
                } else if (result.error) {
                  const fileName = result.file.split('/').pop();
                  
                  const issueTitle = `⚠️ Scan error for ${fileName}`;
                  const issueBody = `
          # Scan Error Alert

          An error occurred while scanning the PDF file: \`${result.file}\`

          ## Error Details
          - **Error**: ${result.error}
          ${result.job_id ? `- **Job ID**: ${result.job_id}` : ''}

          Please review this file manually or try scanning again.
          `;
                  
                  console.log(`Creating issue for scan error: ${fileName}`);
                  const issueUrl = await createGitHubIssue(issueTitle, issueBody);
                  
                  if (issueUrl) {
                    console.log(`Issue created successfully: ${issueUrl}`);
                  } else {
                    console.error(`Failed to create issue for ${fileName}`);
                  }
                }
              }
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          npm install axios
          node create-issues.js

  convert-to-markdown:
    name: Convert PDFs to Markdown
    needs: [detect-pdf-changes, scan-with-falcon]
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install axios fs-extra

      - name: Prepare for conversion
        env:
          SCAN_RESULTS: ${{ needs.scan-with-falcon.outputs.scan_results }}
        run: |
          echo 'const fs = require("fs-extra");
          const scanResults = ${{ needs.scan-with-falcon.outputs.scan_results }};
          fs.writeJSONSync("clean_files.json", 
            scanResults.filter(result => result.clean === true)
              .map(result => result.file)
          );' > prepare-clean-files.js
          
          node prepare-clean-files.js
          
          if [ -f "clean_files.json" ] && [ "$(cat clean_files.json | jq 'length')" -gt 0 ]; then
            echo "Clean files found, proceeding with conversion."
          else
            echo "No clean files found for conversion."
            exit 0
          fi

      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          PROMPT_FILE="AI_PROMPT_MARKDOWN_CONVERT.md"
          if [ -f "$PROMPT_FILE" ]; then
            PROMPT_VERSION=$(git log -1 --format="%s" -- "$PROMPT_FILE" | grep -oE "V[0-9]+\.[0-9]+" || echo "V1.0")
            echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT
            echo "AI Prompt version detected: $PROMPT_VERSION"
          else
            echo "prompt_version=V1.0" >> $GITHUB_OUTPUT
            echo "AI Prompt file not found, using default version V1.0"
          fi

      - name: Convert PDFs to Markdown with Gemini
        id: convert-pdfs
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PROMPT_VERSION: ${{ steps.get-prompt-version.outputs.prompt_version }}
        run: |
          cat > convert-to-markdown.js << 'EOL'
          const axios = require('axios');
          const fs = require('fs-extra');
          const path = require('path');
          const { execSync } = require('child_process');

          // Function to read the AI prompt
          async function readAIPrompt() {
            try {
              return await fs.readFile('AI_PROMPT_MARKDOWN_CONVERT.md', 'utf8');
            } catch (error) {
              console.error('Error reading AI prompt file:', error.message);
              return "Please convert this PDF to a well-formatted markdown document, maintaining all headers, structure, and information from the original document. Create proper markdown formatting for headings, lists, tables, and code blocks as needed.";
            }
          }

          // Function to convert binary data to base64
          function binaryToBase64(binary) {
            return Buffer.from(binary).toString('base64');
          }

          // Function to convert PDF to Markdown using Gemini
          async function convertToMarkdown(pdfPath, promptText, model = "gemini-2.0-flash") {
            try {
              console.log(`Converting ${pdfPath} to markdown using ${model}...`);
              
              // Read PDF file as binary
              const pdfData = await fs.readFile(pdfPath);
              const pdfBase64 = binaryToBase64(pdfData);
              
              const requestData = {
                contents: [
                  {
                    role: "user",
                    parts: [
                      { text: promptText },
                      {
                        inline_data: {
                          mime_type: "application/pdf",
                          data: pdfBase64
                        }
                      }
                    ]
                  }
                ],
                generationConfig: {
                  temperature: 0.2,
                  maxOutputTokens: 32768
                }
              };
              
              const apiUrl = `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`;
              
              const response = await axios.post(apiUrl, requestData, {
                headers: {
                  'Content-Type': 'application/json'
                }
              });
              
              // Check for valid response
              if (response.data && 
                  response.data.candidates && 
                  response.data.candidates[0] && 
                  response.data.candidates[0].content &&
                  response.data.candidates[0].content.parts &&
                  response.data.candidates[0].content.parts[0] &&
                  response.data.candidates[0].content.parts[0].text) {
                
                return {
                  markdown: response.data.candidates[0].content.parts[0].text,
                  model: model
                };
              } else {
                console.error('Invalid response format from Gemini API:', JSON.stringify(response.data, null, 2));
                throw new Error('Invalid response format from Gemini API');
              }
            } catch (error) {
              console.error(`Error converting ${pdfPath} with ${model}:`, error.message);
              if (model === "gemini-2.0-flash" && error.message.includes('400')) {
                console.log('Attempting fallback to gemini-2.0-flash-lite...');
                return convertToMarkdown(pdfPath, promptText, "gemini-2.0-flash-lite");
              }
              throw error;
            }
          }

          // Function to create the markdown file path
          function createMarkdownFilePath(pdfPath) {
            // Replace "Annual Security Reports" with "Markdown Conversions"
            const relativePath = pdfPath.replace(/^Annual Security Reports\//, 'Markdown Conversions/');
            // Replace .pdf extension with .md
            return relativePath.replace(/\.pdf$/, '.md');
          }

          // Function to ensure directory exists
          async function ensureDirectoryExists(filePath) {
            const directory = path.dirname(filePath);
            await fs.ensureDir(directory);
          }

          // Main function
          async function main() {
            try {
              // Read the list of clean files
              const cleanFiles = await fs.readJson('clean_files.json');
              console.log(`Processing ${cleanFiles.length} clean PDF files...`);
              
              // Read the AI prompt
              const promptText = await readAIPrompt();
              
              // Process each clean file
              for (const pdfPath of cleanFiles) {
                try {
                  // Convert PDF to markdown
                  const result = await convertToMarkdown(pdfPath, promptText);
                  
                  // Create markdown file path
                  const markdownPath = createMarkdownFilePath(pdfPath);
                  
                  // Ensure directory exists
                  await ensureDirectoryExists(markdownPath);
                  
                  // Save markdown to file
                  await fs.writeFile(markdownPath, result.markdown);
                  console.log(`Saved markdown to ${markdownPath}`);
                  
                  // Add and commit the file
                  try {
                    execSync(`git config --local user.name "GitHub Action"`);
                    execSync(`git config --local user.email "action@github.com"`);
                    execSync(`git add "${markdownPath}"`);
                    const commitMessage = `AI Prompt ${process.env.PROMPT_VERSION} Model ${result.model}`;
                    execSync(`git commit -m "${commitMessage}" "${markdownPath}"`);
                    console.log(`Committed ${markdownPath} with message: ${commitMessage}`);
                  } catch (gitError) {
                    console.error(`Git error for ${markdownPath}:`, gitError.message);
                  }
                } catch (conversionError) {
                  console.error(`Failed to convert ${pdfPath}:`, conversionError.message);
                }
              }
              
              // Push changes
              try {
                execSync('git push');
                console.log('Pushed changes to repository');
              } catch (pushError) {
                console.error('Error pushing changes:', pushError.message);
              }
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          npm install axios fs-extra
          node convert-to-markdown.js
 | awk '{print $2}' | grep -E '^Annual Security Reports/')
          
          # Check if any new PDFs were added (not modified or deleted)
          if [ -z "$CHANGED_FILES" ]; then
            echo "No new PDF files detected."
            echo "has_new_pdfs=false" >> $GITHUB_OUTPUT
            echo "pdf_files=[]" >> $GITHUB_OUTPUT
          else
            echo "New PDF files detected:"
            echo "$CHANGED_FILES"
            
            # Convert to JSON array format without relying on jq
            JSON_FILES="["
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                # Properly escape the file path for JSON
                ESCAPED_FILE=$(echo "$file" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
                if [ "$JSON_FILES" != "[" ]; then
                  JSON_FILES="${JSON_FILES},"
                fi
                JSON_FILES="${JSON_FILES}\"${ESCAPED_FILE}\""
              fi
            done <<< "$CHANGED_FILES"
            JSON_FILES="${JSON_FILES}]"
            
            echo "has_new_pdfs=true" >> $GITHUB_OUTPUT
            echo "pdf_files=$JSON_FILES" >> $GITHUB_OUTPUT
          fi

  scan-with-falcon:
    name: Scan PDFs with Falcon Hybrid-Analysis
    needs: detect-pdf-changes
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    outputs:
      scan_results: ${{ steps.process-scan-results.outputs.scan_results }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install axios form-data fs-extra

      - name: Scan PDFs with Falcon Hybrid-Analysis
        id: scan-pdfs
        env:
          HYBRID_ANALYSIS_API_KEY: ${{ secrets.HYBRID_ANALYSIS_API_KEY }}
          PDF_FILES: ${{ needs.detect-pdf-changes.outputs.pdf_files }}
        run: |
          cat > scan-pdfs.js << 'EOL'
          const axios = require('axios');
          const FormData = require('form-data');
          const fs = require('fs');
          const path = require('path');
          const fsExtra = require('fs-extra');

          // Function to submit a file to Hybrid Analysis
          async function submitScan(filePath) {
            try {
              console.log(`Preparing to scan: ${filePath}`);
              
              const fileName = path.basename(filePath);
              
              // Check if file exists
              if (!fs.existsSync(filePath)) {
                console.error(`File not found: ${filePath}`);
                return { file: filePath, error: 'File not found', clean: false };
              }
              
              const form = new FormData();
              form.append('file', fs.createReadStream(filePath));
              form.append('environment_id', '300'); // Windows 11 64-bit
              form.append('scan_type', 'full');
                
              console.log(`Submitting ${fileName} to Falcon Hybrid Analysis...`);
              
              const submitResponse = await axios.post('https://www.hybrid-analysis.com/api/v2/submit/file', form, {
                headers: {
                  ...form.getHeaders(),
                  'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                  'user-agent': 'Falcon Sandbox'
                }
              });
              
              if (submitResponse.data && submitResponse.data.job_id) {
                console.log(`Submission successful for ${fileName}. Job ID: ${submitResponse.data.job_id}`);
                
                // Poll for results
                let scanComplete = false;
                let attempts = 0;
                let scanResult = null;
                
                while (!scanComplete && attempts < 20) {
                  await new Promise(resolve => setTimeout(resolve, 30000)); // Wait for 30 seconds
                  attempts++;
                  
                  try {
                    console.log(`Checking scan status for ${fileName} (attempt ${attempts})...`);
                    const statusResponse = await axios.get(`https://www.hybrid-analysis.com/api/v2/report/${submitResponse.data.job_id}/state`, {
                      headers: {
                        'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                        'user-agent': 'Falcon Sandbox'
                      }
                    });
                    
                    if (statusResponse.data && statusResponse.data.state === 'SUCCESS') {
                      console.log(`Scan complete for ${fileName}`);
                      scanComplete = true;
                      
                      // Get full report
                      const reportResponse = await axios.get(`https://www.hybrid-analysis.com/api/v2/report/${submitResponse.data.job_id}/summary`, {
                        headers: {
                          'api-key': process.env.HYBRID_ANALYSIS_API_KEY,
                          'user-agent': 'Falcon Sandbox'
                        }
                      });
                      
                      scanResult = {
                        file: filePath,
                        job_id: submitResponse.data.job_id,
                        report_url: `https://www.hybrid-analysis.com/sample/${reportResponse.data.sha256}/`,
                        verdict: reportResponse.data.verdict,
                        threat_score: reportResponse.data.threat_score,
                        malware_family: reportResponse.data.malware_family || 'None',
                        clean: reportResponse.data.verdict === 'no specific threat' || reportResponse.data.threat_score < 10
                      };
                    } else if (statusResponse.data && statusResponse.data.state === 'ERROR') {
                      console.error(`Scan error for ${fileName}: ${statusResponse.data.message || 'Unknown error'}`);
                      scanComplete = true;
                      scanResult = { 
                        file: filePath, 
                        error: statusResponse.data.message || 'Scan failed',
                        clean: false 
                      };
                    }
                  } catch (error) {
                    console.error(`Error checking scan status for ${fileName}:`, error.message);
                  }
                }
                
                if (!scanComplete) {
                  console.error(`Scan timed out for ${fileName} after ${attempts} attempts`);
                  return { 
                    file: filePath, 
                    job_id: submitResponse.data.job_id,
                    error: 'Scan timed out', 
                    clean: false 
                  };
                }
                
                return scanResult;
              } else {
                console.error(`Submission failed for ${fileName}`);
                return { 
                  file: filePath, 
                  error: 'Submission failed', 
                  clean: false 
                };
              }
            } catch (error) {
              console.error(`Error scanning ${filePath}:`, error.message);
              return { 
                file: filePath, 
                error: `Scanning error: ${error.message}`, 
                clean: false 
              };
            }
          }

          async function main() {
            try {
              const pdfFiles = JSON.parse(process.env.PDF_FILES);
              console.log(`Processing ${pdfFiles.length} PDF files`);
              
              const results = [];
              
              for (const filePath of pdfFiles) {
                const result = await submitScan(filePath);
                results.push(result);
              }
              
              // Write results to file for the next step
              fsExtra.writeJSONSync('scan_results.json', results);
              console.log('Scan results saved to scan_results.json');
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          node scan-pdfs.js

      - name: Process scan results
        id: process-scan-results
        run: |
          if [ -f "scan_results.json" ]; then
            SCAN_RESULTS=$(cat scan_results.json)
            # Escape JSON for GitHub Actions output
            SCAN_RESULTS="${SCAN_RESULTS//'%'/'%25'}"
            SCAN_RESULTS="${SCAN_RESULTS//$'\n'/'%0A'}"
            SCAN_RESULTS="${SCAN_RESULTS//$'\r'/'%0D'}"
            echo "scan_results=$SCAN_RESULTS" >> $GITHUB_OUTPUT
            
            echo "Scan results processed."
          else
            echo "Error: scan_results.json not found"
            echo "scan_results=[]" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload scan results as artifact
        uses: actions/upload-artifact@v3
        with:
          name: falcon-scan-results
          path: scan_results.json
          retention-days: 5

  create-issues-for-threats:
    name: Create Issues for Threats
    needs: [detect-pdf-changes, scan-with-falcon]
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Create issues for malicious files
        env:
          SCAN_RESULTS: ${{ needs.scan-with-falcon.outputs.scan_results }}
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
          REPO_OWNER: jacobdjwilson
          REPO_NAME: awesome-annual-security-reports
        run: |
          cat > create-issues.js << 'EOL'
          const axios = require('axios');

          async function createGitHubIssue(title, body) {
            try {
              const response = await axios.post(
                `https://api.github.com/repos/${process.env.REPO_OWNER}/${process.env.REPO_NAME}/issues`,
                {
                  title: title,
                  body: body
                },
                {
                  headers: {
                    'Authorization': `token ${process.env.GITHUB_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                }
              );
              return response.data.html_url;
            } catch (error) {
              console.error('Error creating GitHub issue:', error.message);
              return null;
            }
          }

          async function main() {
            try {
              const scanResults = JSON.parse(process.env.SCAN_RESULTS);
              
              for (const result of scanResults) {
                // Create issues only for files that aren't clean
                if (result.clean === false && !result.error) {
                  const fileName = result.file.split('/').pop();
                  
                  const issueTitle = `⚠️ Security threat detected in ${fileName}`;
                  const issueBody = `
          # Security Threat Alert

          A security threat was detected in the PDF file: \`${result.file}\`

          ## Scan Details
          - **Report URL**: [Falcon Hybrid Analysis Report](${result.report_url})
          - **Verdict**: ${result.verdict}
          - **Threat Score**: ${result.threat_score}
          - **Malware Family**: ${result.malware_family || 'None'}

          Please review this file carefully before proceeding with any markdown conversion.
          `;
                  
                  console.log(`Creating issue for malicious file: ${fileName}`);
                  const issueUrl = await createGitHubIssue(issueTitle, issueBody);
                  
                  if (issueUrl) {
                    console.log(`Issue created successfully: ${issueUrl}`);
                  } else {
                    console.error(`Failed to create issue for ${fileName}`);
                  }
                } else if (result.error) {
                  const fileName = result.file.split('/').pop();
                  
                  const issueTitle = `⚠️ Scan error for ${fileName}`;
                  const issueBody = `
          # Scan Error Alert

          An error occurred while scanning the PDF file: \`${result.file}\`

          ## Error Details
          - **Error**: ${result.error}
          ${result.job_id ? `- **Job ID**: ${result.job_id}` : ''}

          Please review this file manually or try scanning again.
          `;
                  
                  console.log(`Creating issue for scan error: ${fileName}`);
                  const issueUrl = await createGitHubIssue(issueTitle, issueBody);
                  
                  if (issueUrl) {
                    console.log(`Issue created successfully: ${issueUrl}`);
                  } else {
                    console.error(`Failed to create issue for ${fileName}`);
                  }
                }
              }
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          npm install axios
          node create-issues.js

  convert-to-markdown:
    name: Convert PDFs to Markdown
    needs: [detect-pdf-changes, scan-with-falcon]
    if: needs.detect-pdf-changes.outputs.has_new_pdfs == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install axios fs-extra

      - name: Prepare for conversion
        env:
          SCAN_RESULTS: ${{ needs.scan-with-falcon.outputs.scan_results }}
        run: |
          echo 'const fs = require("fs-extra");
          const scanResults = ${{ needs.scan-with-falcon.outputs.scan_results }};
          fs.writeJSONSync("clean_files.json", 
            scanResults.filter(result => result.clean === true)
              .map(result => result.file)
          );' > prepare-clean-files.js
          
          node prepare-clean-files.js
          
          if [ -f "clean_files.json" ] && [ "$(cat clean_files.json | jq 'length')" -gt 0 ]; then
            echo "Clean files found, proceeding with conversion."
          else
            echo "No clean files found for conversion."
            exit 0
          fi

      - name: Get AI prompt version
        id: get-prompt-version
        run: |
          PROMPT_FILE="AI_PROMPT_MARKDOWN_CONVERT.md"
          if [ -f "$PROMPT_FILE" ]; then
            PROMPT_VERSION=$(git log -1 --format="%s" -- "$PROMPT_FILE" | grep -oE "V[0-9]+\.[0-9]+" || echo "V1.0")
            echo "prompt_version=$PROMPT_VERSION" >> $GITHUB_OUTPUT
            echo "AI Prompt version detected: $PROMPT_VERSION"
          else
            echo "prompt_version=V1.0" >> $GITHUB_OUTPUT
            echo "AI Prompt file not found, using default version V1.0"
          fi

      - name: Convert PDFs to Markdown with Gemini
        id: convert-pdfs
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          PROMPT_VERSION: ${{ steps.get-prompt-version.outputs.prompt_version }}
        run: |
          cat > convert-to-markdown.js << 'EOL'
          const axios = require('axios');
          const fs = require('fs-extra');
          const path = require('path');
          const { execSync } = require('child_process');

          // Function to read the AI prompt
          async function readAIPrompt() {
            try {
              return await fs.readFile('AI_PROMPT_MARKDOWN_CONVERT.md', 'utf8');
            } catch (error) {
              console.error('Error reading AI prompt file:', error.message);
              return "Please convert this PDF to a well-formatted markdown document, maintaining all headers, structure, and information from the original document. Create proper markdown formatting for headings, lists, tables, and code blocks as needed.";
            }
          }

          // Function to convert binary data to base64
          function binaryToBase64(binary) {
            return Buffer.from(binary).toString('base64');
          }

          // Function to convert PDF to Markdown using Gemini
          async function convertToMarkdown(pdfPath, promptText, model = "gemini-2.0-flash") {
            try {
              console.log(`Converting ${pdfPath} to markdown using ${model}...`);
              
              // Read PDF file as binary
              const pdfData = await fs.readFile(pdfPath);
              const pdfBase64 = binaryToBase64(pdfData);
              
              const requestData = {
                contents: [
                  {
                    role: "user",
                    parts: [
                      { text: promptText },
                      {
                        inline_data: {
                          mime_type: "application/pdf",
                          data: pdfBase64
                        }
                      }
                    ]
                  }
                ],
                generationConfig: {
                  temperature: 0.2,
                  maxOutputTokens: 32768
                }
              };
              
              const apiUrl = `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${process.env.GEMINI_API_KEY}`;
              
              const response = await axios.post(apiUrl, requestData, {
                headers: {
                  'Content-Type': 'application/json'
                }
              });
              
              // Check for valid response
              if (response.data && 
                  response.data.candidates && 
                  response.data.candidates[0] && 
                  response.data.candidates[0].content &&
                  response.data.candidates[0].content.parts &&
                  response.data.candidates[0].content.parts[0] &&
                  response.data.candidates[0].content.parts[0].text) {
                
                return {
                  markdown: response.data.candidates[0].content.parts[0].text,
                  model: model
                };
              } else {
                console.error('Invalid response format from Gemini API:', JSON.stringify(response.data, null, 2));
                throw new Error('Invalid response format from Gemini API');
              }
            } catch (error) {
              console.error(`Error converting ${pdfPath} with ${model}:`, error.message);
              if (model === "gemini-2.0-flash" && error.message.includes('400')) {
                console.log('Attempting fallback to gemini-2.0-flash-lite...');
                return convertToMarkdown(pdfPath, promptText, "gemini-2.0-flash-lite");
              }
              throw error;
            }
          }

          // Function to create the markdown file path
          function createMarkdownFilePath(pdfPath) {
            // Replace "Annual Security Reports" with "Markdown Conversions"
            const relativePath = pdfPath.replace(/^Annual Security Reports\//, 'Markdown Conversions/');
            // Replace .pdf extension with .md
            return relativePath.replace(/\.pdf$/, '.md');
          }

          // Function to ensure directory exists
          async function ensureDirectoryExists(filePath) {
            const directory = path.dirname(filePath);
            await fs.ensureDir(directory);
          }

          // Main function
          async function main() {
            try {
              // Read the list of clean files
              const cleanFiles = await fs.readJson('clean_files.json');
              console.log(`Processing ${cleanFiles.length} clean PDF files...`);
              
              // Read the AI prompt
              const promptText = await readAIPrompt();
              
              // Process each clean file
              for (const pdfPath of cleanFiles) {
                try {
                  // Convert PDF to markdown
                  const result = await convertToMarkdown(pdfPath, promptText);
                  
                  // Create markdown file path
                  const markdownPath = createMarkdownFilePath(pdfPath);
                  
                  // Ensure directory exists
                  await ensureDirectoryExists(markdownPath);
                  
                  // Save markdown to file
                  await fs.writeFile(markdownPath, result.markdown);
                  console.log(`Saved markdown to ${markdownPath}`);
                  
                  // Add and commit the file
                  try {
                    execSync(`git config --local user.name "GitHub Action"`);
                    execSync(`git config --local user.email "action@github.com"`);
                    execSync(`git add "${markdownPath}"`);
                    const commitMessage = `AI Prompt ${process.env.PROMPT_VERSION} Model ${result.model}`;
                    execSync(`git commit -m "${commitMessage}" "${markdownPath}"`);
                    console.log(`Committed ${markdownPath} with message: ${commitMessage}`);
                  } catch (gitError) {
                    console.error(`Git error for ${markdownPath}:`, gitError.message);
                  }
                } catch (conversionError) {
                  console.error(`Failed to convert ${pdfPath}:`, conversionError.message);
                }
              }
              
              // Push changes
              try {
                execSync('git push');
                console.log('Pushed changes to repository');
              } catch (pushError) {
                console.error('Error pushing changes:', pushError.message);
              }
            } catch (error) {
              console.error('Error in main function:', error.message);
              process.exit(1);
            }
          }

          main();
          EOL
          
          npm install axios fs-extra
          node convert-to-markdown.js
